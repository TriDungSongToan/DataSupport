.GetID() -> Script
Returns the corresponding script metatable and passcode of the current lua file. This is meant to be called at the start of every card script.
---
aux.addContinuousLizardCheck(Card c, int location, int tRange, int tRange2) -> Effect
Creates and registers an [Effect](/api/types/Effect) to a card that affects other cards such that they will be excluded by ["Clock Lizard"](https://yugipedia.com/wiki/Clock_Lizard) when checking what cards it can return to the Extra Deck.
---
aux.AddEquipProcedure(Card c, int tp, TargetFilterFunction filter, EquipLimitFunction eqlimit, EffectCost cost, EffectTarget tg, EffectOperation op, EffectCondition con, int prop) -> Effect
Creates and registers an effect to an Equip Spell Card that allows it to be equipped.
---
aux.addLizardCheck(Card c) -> Effect
Creates and registers an [Effect](/api/types/Effect) to a card such that it will be excluded by ["Clock Lizard"](https://yugipedia.com/wiki/Clock_Lizard) when checking what cards it can return to the Extra Deck.
---
aux.AddMaleficSummonProcedure(Card c, int code, int loc, function excond) -> function
Procedure for "Malefic" monsters' Special Summon (also includes handling of "Malefic Paradox Gear"'s effect)
---
aux.AddNormalSetProcedure(Card c, bool ns, bool opt, int min, int max, int sum_type_val, int desc, function f, function sumop) -> Effect
Adds a procedure to a monster that can be Normal Summoned/Set. (Card c) is the card receiving the effect. If both (bool ns) and (bool opt) are set to true, the effect is created with code EFFECT_SET_PROC, otherwise EFFECT_LIMIT_SET_PROC is used. (int min) and (int max) are the number of tributes to use. (int sum_type) is the type of the summon and defaults to SUMMON_TYPE_TRIBUTE. (string desc) is the description used when the player attempts the summon (usable via aux.Stringid). (function f) is a function that must be fulfilled by the tributes and (function sumop) is a special function that must be executed with the tributes
---
aux.AddNormalSummonProcedure(Card c, bool ns, bool opt, int min, int max, int sum_type_val, int desc, function f, function sumop) -> Effect
(To be added)
---
aux.AddPersistentProcedure(Card c, int|nil p, function|nil f, int|nil category, int|nil property, int|nil hint1, int|nil hint2, function|nil con, function|nil cost, function|nil tg, function|nil op, bool|nil anypos) -> 
Adds the Persistent Trap Procedure where is the player, setting 0 will limit to monsters you control, setting to 1 will be your opponent and PLAYER_ALL/nil will be for either player. (function f) is the filters on which monsters you can target. (bool anypos) is a check if the target needs to be face-up. Setting this to true will allow it to be targeted even if it isn't face-up.
---
aux.AddPreDrawSkillProcedure(Card c, int coverNum, any drawless, any skillcon, any skillop, any countlimit) -> Effect
Function for the skills that "trigger" at the start of the turn/Before the Draw Phase, - c: the card (card), - coverNum: the Number of the cover (int), - drawless: if the player draw 1 less card at the start of the duel (bool), - flip con: condition to activate the skill (function), - flipOp: operation related to the skill activation (function)
---
aux.AddSkillProcedure(Card c, int coverNum, any drawless, any skillcon, any skillop, any countlimit) -> Effect
Procedure for basic skill. - c: the card (card), - coverNum: the Number of the cover (int). - drawless: if the player draw 1 less card at the start of the duel (bool), - flip con: condition to activate the skill (function), - flipOp: operation related to the skill activation (function)
---
aux.addTempLizardCheck(Card c, int tp, TargetFilterFunction filter, int reset, int tRange, int tRange2, int resetcount) -> Effect
Creates and registers an [Effect](/api/types/Effect) to the duel that affects cards such that they will be excluded by ["Clock Lizard"](https://yugipedia.com/wiki/Clock_Lizard) when checking what cards it can return to the Extra Deck.
---
aux.AddUnionProcedure(Card c, function f, bool oldrule, bool oldprotect) -> 
Adds the Union Procedure to (Card c) where (function f) is the cards you can equip the Union monster to, and (bool oldrule) is a check to apply old rulings of the Union monster. if oldprotect is not nil, uses old rules for destroy replacement (If the equipped monster would be destroyed, destroy this card instead.)
---
aux.AddValuesReset(function resetfunc) -> 
Executes, at EVENT_TURN_END, the reset function(s) passed as argument (function resetfunc)
---
aux.AddVrainsSkillProcedure(Card c, function skillcon, function skillop, any efftype) -> Effect
Procedure for Vrains Skills. -flip con: condition to activate the skill (function), -flipOp: operation related to the skill activation (function), -efftype: Event to trigger the Skill, default to EVENT_FREE_CHAIN. Additionally accepts EFFECT_NEGATE_SKILL for Anti Skill (int)
---
aux.AddZWEquipLimit(Card c, function con, any equipval, any equipop, any linkedeff, any prop, any resetflag, any resetcount) -> 
Equip Limit Proc for cards that equip themselves to another card. - con - condition for when the card can equip to another 'f(e)', - equipval - filter for the equip target,  - equipop - what happens when the card is equipped to the target, - (tc is equip target, c is equip card), - linkedeffect - usually the effect of Card c that equips, this ensures Phantom of Chaos handling, - prop - extra effect properties, - resetflag/resetcount - resets
---
aux.AND(any ...) -> bool
First (...) is a list of functions which will be used to check the parameters in the second set of (...), separated with "and". The second set of (...) is applied automatically when used as a filter.
---
aux.AnnounceAnotherAttribute(Card c, int player) -> int
Function deprecated since version 40.0.0. Use "Card.AnnounceAnotherAttribute" instead
---
aux.AnnounceAnotherRace(Card c, int player) -> int
Function deprecated since version 40.0.0. Use "Card.AnnounceAnotherRace" instead
---
aux.AskAny(any stringid) -> int
Function deprecated since version 40.0.0. Use "Duel.AskAny" instead
---
aux.AskEveryone(any stringid) -> int
Function deprecated since version 40.0.0. Use "Duel.AskEveryone" instead
---
aux.AttractionEquipCon(any self) -> function
Returns a function which checks if the card is equipped and if the equipped monster is controlled by the player (self=true) or by the opponent (self=false)
---
aux.bdcon(Effect e, int tp, Group|nil eg, int ep, int ev, Effect re, int r, int rp) -> bool
Default condition of EVENT_BATTLE_DESTROYING. "When this card destroys a monster by battle" and checks if itself is still the same state after battle.
---
aux.bdgcon(Effect e, int tp, Group|nil eg, int ep, int ev, Effect re, int r, int rp) -> bool
Condition of EVENT_BATTLE_DESTROYING. "When this card destroys a monster by battle and sends it to the Graveyard" and checks if itself is still the same state after battle.
---
aux.bdocon(Effect e, int tp, Group|nil eg, int ep, int ev, Effect re, int r, int rp) -> bool
Condition of EVENT_BATTLE_DESTROYING. "When this card destroys an opponent's monster by battle" and checks if itself is still the same state after battle.
---
aux.bdogcon(Effect e, int tp, Group|nil eg, int ep, int ev, Effect re, int r, int rp) -> bool
Condition of EVENT_BATTLE_DESTROYING. "When this card destroys an opponent's monster by battle and sends it to the Graveyard" and checks if itself is still the same state after battle.
---
aux.BeginPuzzle() -> 
Sets up the beginning of a puzzle, causing the player to lose during the End Phase
---
aux.BitSplit(int number) -> table
Auxiliary function to help printing hints for attribute-related cards such as Cynet Codec
---
aux.CanActivateSkill(int player) -> bool
(To be added)
---
aux.cannotmatfilter(int val1, int ...) -> int
Returns the value(s) passed formatted to be used for EFFECT_CANNOT_BE_MATERIAL.
---
aux.CanPlaceCounter(Card c, int counter_type) -> bool
Function deprecated since version 40.0.0. Use "Card.PlacesCounter" instead
---
aux.chainreg(Effect e, int tp, Group|nil eg, int ep, int ev, Effect re, int r, int rp) -> 
Flag effect used for Spell Counter (that are put when the Spell card resolves)
---
aux.ChangeBattleDamage(int player, int value) -> int
Changes the battle damage that (int player) would have taken to (int value)
---
aux.CheckPendulumZones(int player) -> bool
Function deprecated since version 40.0.0. Use "Duel.CheckPendulumZones" instead
---
aux.CheckSkillNegation(any e, any tp) -> bool
Function to check whether the Skill would be negated by Anti Skill
---
aux.CheckStealEquip(Card c, Effect e, int tp) -> bool
(To be added)
---
aux.CheckSummonGate(any tp, any count) -> bool|int
If (int count) is provided, checks if the player (int player) is affected by Summon Gate and if that the argument surpass  the maximum number of summons before Summon Gate's effect applies. If (int count) is not provided, returns the remains number of summons that would cause Summon Gate's effect to apply
---
aux.CheckValidExtra(Card c, int player, Group sg, Group mg, any lc, Group emt, function filt) -> bool
Auxiliary function used by the Link Summon procedure.
---
aux.CheckZonesReleaseSummonCheck(Group must, Group oneof, function checkfunc) -> bool
Auxiliary function called by "Duel.SelectReleaseGroupSummon".
---
aux.CheckZonesReleaseSummonCheckSelection(Group must, Group oneof, function checkfunc) -> bool
(To be added)
---
aux.ChkfMMZ(int sumcount) -> bool
"Check for Main Monster Zones". Used in rescon by default. 2nd parenthesis is not required as rescon/cancelcon in aux.SelectUnselectGroup. (Group sg) is the selected group when using aux.SelectUnselectGroup. Evaluates if a int sumcount number of Main Monsters zones are available and/or will be made available to summon the requiring card.
---
aux.ComposeNumberDigitByDigit(int tp, int min, int max) -> int
Makes (int tp) declare a number digit by digit, with a minimum of (int min) and maximum of (int max)
---
aux.continuousOp(any ...) -> function
(To be added)
---
aux.CostWithReplace(function base, int replacecode, function extracon, function alwaysexecute) -> function
(To be added)
---
aux.createContinuousLizardCheck(Card c, int location, int tRange, int tRange2) -> Effect
Creates an [Effect](/api/types/Effect) that, when registered to a card, affects other cards such that they will be excluded by ["Clock Lizard"](https://yugipedia.com/wiki/Clock_Lizard) when checking what cards it can return to the Extra Deck.
---
aux.createTempLizardCheck(Card c, TargetFilterFunction filter, int reset, int tRange, int tRange2, int resetcount) -> Effect
Creates an [Effect](/api/types/Effect) that, when registered to the duel, affects cards such that they will be excluded by ["Clock Lizard"](https://yugipedia.com/wiki/Clock_Lizard) when checking what cards it can return to the Extra Deck.
---
aux.CreateUrsarcticSpsummon(any c, any id) -> Effect
Registers to (Card c) a Quick Effect that Special Summons itself from the hand by tributing another level 7 or higher monster from the hand. This is the common effect for "Ursarctic" monsters and already handles the cost replacement from "Ursarctic Big Dipper". (int id) is (Card c)'s ID, to register the effect as HOPT.
---
aux.CreateWitchcrafterReplace(any c, any id) -> Effect
Registers to (Card c) a Field effect (that applies from LOCATION_SZONE) that flags it as replacement for the discard cost of "Witchcrafter" monsters.  (int id) is (Card c)'s ID, to register the effect as HOPT. See "Witchcrafter Scroll" and "Witchcrafter Bystreet".
---
aux.damcon1(Effect e, int tp, Group|nil eg, int ep, int ev, Effect re, int r, int rp) -> bool
Default condition for "If you would take effect damage"
---
aux.DeckMill(any p, any num, any reason) -> bool
proc_maximum (Rush function)
---
aux.DefaultFieldReturnOp(Group rg, Effect e, int tp) -> 
An operation function to be used with `aux.RemoveUntil`. Returns the banished cards to the monster zone. Makes the player select cards to return if there are less available zones than returnable cards.
---
aux.DelayedOperation(Card|Group cs, int phase, int flag, Effect e, int tp, DelayedEffectOperation oper, DelayedEffectCondition cond, int reset, int reset_count, int hint, int effect_desc) -> Effect|nil
Creates an effect that performs an operation on cards each time a given phase is entered.
---
aux.DeleteExtraMaterialGroups(Group emt) -> 
Auxiliary function used by the Link Summon procedure
---
aux.DiscardCost(CardFilter filter, bool other, int count) -> CostFunction
Creates a baseline [cost function](/api/types/EffectCost) used for effects that discard a card(s) as cost, such as `Discard 1 card; ...` (e.g. "Raigeki Break").
---
aux.disfilter1(Card c) -> bool
Function deprecated since version 40.0.0. Use "Card.IsNegatableMonster" instead
---
aux.disfilter2(Card c) -> bool
Function deprecated since version 40.0.0. Use "Card.IsNegatableSpellTrap" instead
---
aux.disfilter3(Card c) -> bool
Function deprecated since version 40.0.0. Use "Card.IsNegatable" instead
---
aux.dncheck() -> function
Auxiliary function that checks for cards with different names, usually used as the resolution condition in aux.SelectUnselectGroup. Internally, it is an application of aux.dpcheck using Card.GetCode as argument
---
aux.dogcon(Effect e, int tp, Group|nil eg, int ep, int ev, Effect re, int r, int rp) -> bool
SetCondition for "is destroyed by your opponent".
---
aux.DoubleSnareValidity(Card c, int range, int property) -> 
Registers that card c has an effect that can negate/destroy trap cards, while it is in the location defined in int range. Used by Double Snare to identify which cards it can destroy. Int property are additional properties other than the default EFFECT_FLAG_CANNOT_DISABLE|EFFECT_FLAG_SINGLE_RANGE.
---
aux.DoubleTributeCon(any e, any tp) -> bool
(To be added)
---
aux.dpcheck(CardPropertyFunction propfn) -> SubgroupCheck
Creates a [SubgroupCheck](/api/types/SubgroupCheck) that returns true for subgroups with cards that have unique/different properties.
---
aux.drawlessop(any ...) -> function
Auxiliary function for skills that have "You draw 1 less card at the beginning of the duel".
---
aux.dxmcostgen(int min, int max, function op) -> function
"Detach Xyz Material Cost Generator". Generates a function to be used by Effect.SetCost in order to detach a number of Xyz Materials from the Effect's handler. (int min) is the minimum number of materials to check for detachment. (int max) is the maximum number of materials to detach or a function that gets called as if by doing max(e,tp) in order to get the value of max detachments. (function op) is an optional function that gets called by passing the effect and the operated group of just detached materials in order to do some additional handling with them.
---
aux.EnableCheckReincarnation(Card c) -> 
Auxiliary function for "Salamangreat" Reincarnation procedure. Enables reincarnation links.
---
aux.EnableExtraRules(any c, any card, any init, any ...) -> 
Functions to automate consistent start-of-duel activations for DuelModes like Speed Duel, Sealed Duel, etc
---
aux.EnableExtraRulesOperation(any card, any init, any ...) -> 
(To be added)
---
aux.EnableNeosReturn(Card c, int extracat, function extrainfo, function extraop) -> 
Adds the effect to shuffle the card into the Extra Deck at the End Phase (most commonly used by "Neos" Fusion Monsters). If provided, "extracat", "extrainfo" and "extraop" will add additional effect categories, operation info and operations respectively to the effect. The Condition, Target and Operation functions of this effect, named NeosReturnCondition1/2, NeosReturnTarget and NeosReturnOperation, are detailed in cards_specific_functions.lua.
---
aux.EnableSpiritReturn(Card c, int event1, int ...) -> 
Function deprecated since version 40.0.0. Use "Spirit.AddProcedure" instead
---
aux.EquipByEffectAndLimitRegister(Card c, Effect e) -> bool
Function deprecated since version 40.0.0. Use "Card.EquipByEffectAndLimitRegister" instead
---
aux.EquipByEffectLimit(Card c, Effect e, int tp, Card tc, int|nil code, bool mustbefaceup) -> bool
Function deprecated since version 40.0.0. Use "Card.EquipByEffectLimit" instead
---
aux.EquipEquip(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp) -> 
Used to equip the Equip Card to the targeted monster. This would be used if you cannot use the Equip Procedure for your Equip Card activation.
---
aux.EvilHeroLimit(any e, any se, any sp, any st) -> int
Default SetValue for the effect of "Evil HERO" monsters that use EFFECT_SPSUMMON_CONDITION. Must be used due to the existence of "Supreme King Castle"
---
aux.evospcon(Effect e, int tp, Group|nil eg, int ep, int ev, Effect re, int r, int rp) -> bool
Default SetCondition for "Summoned by a "Evolsaur" monster"
---
aux.exccon(Effect e) -> bool
SetCondition for "except the turn this card was sent to the Graveyard".
---
aux.FaceupFilter(function f, any ...) -> function
Filter to check face-up cards that match (function f) where (...) are extra parameters to f. Can be used as the function parameter in SelectMatchingCard/Target and IsExistingMatchingCard/Target.
---
aux.FALSE() -> bool
Function that returns false
---
aux.fieldop(any ...) -> bool
(To be added)
---
aux.FieldSummonProcTg(function f1, function f2) -> bool
(To be added)
---
aux.FilterBoolFunction(function f, any ...) -> bool
Used in filters (with parameter (Card c)) to check a function and its (...) parameters
---
aux.FilterBoolFunctionEx(function f, int value) -> bool
Used filter for the Fusion, Xyz, Synchro and Link Procedures where (function f) can be Card.IsRace, Card.IsAttribute and Card.IsType and (int value) corresponds to the required Race, Attribute and Type.
---
aux.FilterBoolFunctionEx2(function f, any ...) -> bool
(To be added)
---
aux.FilterEqualFunction(function f, int value, any ...) -> bool
Used in filters (with parameter (Card c)) to check a function and its (...) parameters is equal to the inputted (int value).
---
aux.FilterFaceupFunction(function f) -> function
Function deprecated since version 40.0.0. Use "aux.FaceupFilter" instead
---
aux.FilterMaximumSideFunction(any f, any ...) -> function
(To be added)
---
aux.FilterMaximumSideFunctionEx(any f, any ...) -> function
(To be added)
---
aux.FilterSummonCode(any ...) -> bool
Used for MaterialTypes boolean filters (works for IsRace, IsAttribute, IsType)
---
aux.FossilLimit(any e, any se, any sp, any st) -> bool
(To be added)
---
aux.FunctionWithNamedArgs(function f, string|table ...) -> function
Creates a new function that can handle both named arguments (as a table) and regular arguments.
---
aux.FusionProcedure() -> function
(To be added)
---
aux.fuslimit(Effect e, Effect se, int sp, int st) -> bool
SPSUMMON condition "Must be Fusion Summoned"
---
aux.gbspcon(Effect e, int tp, Group|nil eg, int ep, int ev, Effect re, int r, int rp) -> bool
Default SetCondition for "Summoned by a "Gladiator Beast" monster"
---
aux.GeminiNormalCondition(Effect e) -> bool
Function deprecated since version 40.0.0. Use Gemini.NormalStatusCondition instead
---
aux.GetAttributeStrings() -> table
(To be added)
---
aux.GetCoinEffectHintString() -> table
(To be added)
---
aux.GetCover(Card c, any coverNum) -> int
Used by the Skill procedure.
---
aux.GetExtraMaterials(int player, Group mustg, Group sc, int summon_type) -> table
(To be added)
---
aux.GetMMZonesPointedTo(int player, function by_filter, int player_location, int oppo_location, int target_player, any ...) -> int
Returns the zone values (bitfield mask) of the Main Monster Zones on the field of "target_player" that are pointed to by any Link Cards, which match the "by_filter" function/filter, in the locations "player_location" and "oppo_location", from the perspective of "player". The filter by default checks that the card is face-up and is a Link Card, any additional check (e.g. archetype) is added onto that. Both locations default to LOCATION_MZONE if not provided since most cards care about zones that any Link Monster points to, if you want to include Link Spells then use LOCATION_ONFIELD, or LOCATION_SZONE to exclude Link Monsters and check for Link Spells only. The second location defaults to the first one if not provided, but 0 can be passed if you need to not count a side of the field for that location. "target_player" defaults to "player" if not provided. "..." are any additional parameters that "by_filter" might need.
---
aux.GetMustBeMaterialGroup(int tp, nil|Group eg, int sump, nil|Card sc, nil|Group g, int r) -> Group
Gets the group that must be used as material (Contacting "C"). (int tp) is the affected player, (nil|Group eg) is all detected materials, (int sump) is the Summoning player, (nil|Card sc) is the card to be Summoned, (nil|Group) g is all the valid usable materials, (int r) is the reason e.g. REASON_SYNCHRO, REASON_XYZ
---
aux.GetRaceStrings(int number) -> table
(To be added)
---
aux.GlobalCheck(any s, function func) -> 
Enables a global check to be used with function "func"
---
aux.HarmonizingMagFilter(Card c, Effect e, function f) -> bool
(To be added)
---
aux.HarmonizingMagFilterXyz(Card c, Effect e, function f) -> bool
(To be added)
---
aux.HasCounterListed(Card c, int counter_type) -> bool
Function deprecated since version 40.0.0. Use "Card.ListsCounter" instead
---
aux.HasListedSetCode(Card c, int ...) -> bool
Function deprecated since version 40.0.0. Use "Card.ListsArchetype" instead
---
aux.IceBarrierDiscardCost() -> function
(To be added)
---
aux.IceBarrierDiscardFilter() -> function
(To be added)
---
aux.IceBarrierDiscardGroup() -> function
(To be added)
---
aux.imval1(Effect e, Card c) -> bool
default filter for EFFECT_CANNOT_BE_BATTLE_TARGET where (Card c) is checked to ensure it's not immune to (Effect e)
---
aux.imval2(Effect e, Card c) -> bool
similar to aux.imval1, but also check if the monster is from opponent.
---
aux.indesfilter(any ...) -> bool
Called by proc_maximum.lua
---
aux.indoval(Effect e, Effect re, int rp) -> bool
Returns if the reason player is equal to 1-effect e's handler player. Commonly used as filter for EFFECT_INDESTRUCTABLE_EFFECT + opponent
---
aux.indsval(Effect e, Effect re, int rp) -> bool
Returns if the reason player is equal to effect e's handler player. Commonly used as filter for EFFECT_INDESTRUCTABLE_EFFECT + self
---
aux.IsArchetypeCodeListed(Card c, int ...) -> bool
Function deprecated since version 40.0.0. Use "Card.ListsCodeWithArchetype" instead
---
aux.IsCardTypeListed(Card c, int ...) -> bool
Function deprecated since version 40.0.0. Use "Card.ListsCardType" instead
---
aux.IsCodeListed(Card c, int ...) -> bool
Function deprecated since version 40.0.0. Use "Card.ListsCode" instead
---
aux.IsGeminiState(Card c) -> bool
Function deprecated since version 40.0.0. Use "Card.ListsCodeAsMaterial" instead
---
aux.IsMaterialListCode(Card c, int ...) -> bool
Function deprecated since version 40.0.0. Use "Card.ListsCodeAsMaterial" instead
---
aux.IsMaterialListSetCard(Card c, int ...) -> bool
Function deprecated since version 40.0.0. Use "Card.ListsArchetypeAsMaterial" instead.
---
aux.IsMaximumMode(Card c) -> bool
(To be added)
---
aux.IsNotGeminiState(Card c) -> bool
(To be added)
---
aux.IsUnionState(Effect effect) -> bool
Used as a default condition to check if the handler of the effect is a Union monster equipped to another monster.
---
aux.IsZone(Card c, int zone, int tp) -> bool
Returns if (card c) is in the (int zone), (int tp) is the reference player.
---
aux.KaijuCondition(Effect e, Card c) -> bool
(To be added)
---
aux.LavaCheck(Group sg, Effect e, int tp, Group mg) -> bool
(To be added)
---
aux.LavaCondition(any required, any filter) -> bool
(To be added)
---
aux.LavaOperation(any required, any filter) -> 
(To be added)
---
aux.LavaTarget(any required, any filter) -> bool
(To be added)
---
aux.LinkProcedure() -> function
(To be added)
---
aux.lnklimit(Effect e, Effect se, int sp, int st) -> bool
SPSUMMON condition "Must be Link Summoned"
---
aux.MainAndExtraGetSummonZones(Card c, int mmz, int emz, Effect e, int sumtype, int sump, int targetp, bool nocheck, bool nolimit, int pos, any nc, any ...) -> int
(To be added)
---
aux.MainAndExtraSpSummonLoop(function|nil func, int sumtype, int sump, int targetp, bool nocheck, bool nolimit, int pos, int mmz, int emz) -> bool
Loops Special Summoning (Group sg) to ensure they go in a valid zone (Extra Monster Zone and Main Monster Zones) where (function func) is a function called after each card in the Group is summoned with the parameters (Effect e, int tp, Group eg, int ep,int ev, Effect re, int r, int rp, Card sc) where (Card sc) is the card that's Summoned. (int sumtype) is the SummonType. (int sump) is the Summoning player. (int targetp) is the target player. (bool nocheck) checks for "ignoring the Summoning conditions". And (bool nolimit) checks for "ignoring proper Summon". (int pos) is the position to be Summoned. (int mmz) is the zones where you can Special Summon monsters in (Group sg) to the Main Monster Zone, which defaults to all Main Monster Zones if there is no input or nil is inputed. (int emz) on the other is similar to (int mmz) but it checks for cards from the Extra Deck which Special Summons to the Extra Monster Zone.
---
aux.MainAndExtraZoneCheckBool(Card c, int mmz, int emz, Effect e, int sumtype, int sump, int targetp, bool nocheck, bool nolimit, int pos, any nc, any ...) -> bool
(To be added)
---
aux.MakeSpecialCheck() -> function
(To be added)
---
aux.MaleficSummonCondition(any cd, int loc, function excon) -> function
Auxiliary function for the summoning procedure of "Malefic" monsters. Checks if the player has the zone to summon and the appropriate monster (cd) to banish.
---
aux.MaleficSummonFilter(Card c, Card cd) -> function
Filter used with AddMaleficSummonProcedure. Returns if card (Card c)'s ID is (cd) and if c can be banished as cost
---
aux.MaleficSummonOperation(any cd, int loc) -> function
Auxiliary function to handle the summoning procedure of "Malefic" monsters. Performs the actual summon of the monster by removing the appropriate monster.
---
aux.MaleficSummonSubstitute(Card c, Card cd, int tp) -> function
Used with the Summoning Procedure of "Malefic" monsters. Checks for the effect of "Malefic Paradox Gear"
---
aux.MaleficSummonTarget() -> function
(To be added)
---
aux.MaleficUniqueFilter(any c) -> function
Used as filter for the uniqueness on field with the "Malefic" monsters
---
aux.MaximumProcedure() -> function
(To be added)
---
aux.MZFilter(Card c, int tp) -> bool
Filter to check monsters if it's on a Main Monster Zone
---
aux.NecroValleyFilter(function f) -> bool
Filter check "not affected by Necrovalley" in addition to its own filter, if used as function filter, (Card target, ...) is defined by default
---
aux.NeosReturnCondition1(any e, any tp, any eg, any ep, any ev, any re, any r, any rp) -> bool
(To be added)
---
aux.NeosReturnCondition2(any e, any tp, any eg, any ep, any ev, any re, any r, any rp) -> bool
(To be added)
---
aux.NeosReturnOperation(Card c, function extraop) -> 
(To be added)
---
aux.NeosReturnSubstituteFilter(Card c) -> bool
Auxiliary filter used by NeosReturnOperation. Returns if Card c can be removed as cost and is Neos Fusion
---
aux.NeosReturnTarget(Card c, any extrainfo) -> 
(To be added)
---
aux.Next(Group g) -> iterator
Iterates over the cards in (Group g) for use with for loops
---
aux.NormalSetCondition1() -> function
(To be added)
---
aux.NormalSetCondition2() -> function
(To be added)
---
aux.NormalSetTarget() -> function
(To be added)
---
aux.NormalSummonCondition1() -> function
(To be added)
---
aux.NormalSummonCondition2() -> function
(To be added)
---
aux.NOT(function f) -> bool
This is equivalent to not f(...), if used as filter checking, (...) is automatically applied
---
aux.NULL() -> nil
Function that returns nil
---
aux.nvfilter(Card c) -> bool
Filter check "not affected by Necrovalley"
---
aux.nzatk(Card c) -> bool
Function deprecated since version 40.0.0. Use "Card.HasNonZeroAttack" instead
---
aux.nzdef(Card c) -> bool
Function deprecated since version 40.0.0. Use "Card.HasNonZeroDefense" instead
---
aux.OR(any ...) -> bool
First (...) is a list of functions which will be used to check the parameters in the second set of (...), separated with "or". The second set of (...) is applied automatically when used as a filter.
---
aux.ParamsFromTable(table t, any key, any ...) -> table
(To be added)
---
aux.PayLPCost(number lp_value, bool pay_until) -> CostFunction
Creates a baseline [cost function](/api/types/EffectCost) used for effects that pay LP as cost, such as `Pay X LP; ...` (e.g. "Instant Fusion").
---
aux.PendulumProcedure(any c) -> function
(To be added)
---
aux.penlimit(Effect e, Effect se, int sp, int st) -> bool
SPSUMMON condition "Must be Pendulum Summoned"
---
aux.PersistentFilter(Effect e, Card c) -> function
(To be added)
---
aux.PersistentTarget(Effect e, Card c) -> function
(To be added)
---
aux.PersistentTargetFilter(Effect e, Card c) -> bool
Default filter for checking if it's targeted by the Persistent Trap.
---
aux.PersistentTgCon(Effect e, Card c) -> function
(To be added)
---
aux.PersistentTgOp(Effect e, Card c) -> function
(To be added)
---
aux.PropertyTableFilter(function f, any ...) -> table
(To be added)
---
aux.PuzzleOp(Effect e, int tp) -> 
Used by aux.BeginPuzzle(), sets the first turn player's LP to 0
---
aux.qlifilter(Effect e, Effect te) -> bool
Default filter used with "Qli" monsters for: "Unaffected by activated monster effects whose original Rank/Level is lower than this card's Level"
---
aux.RegisterClientHint(Card c, int property_code, int reg.player, int s, int o, any str, int reset_code, int ct) -> 
Auxiliary function to simplify registering EFFECT_FLAG_CLIENT_HINT to players. (Card c) is card that creates the HintMessage,  (int property_code) are additional properties like EFFECT_FLAG_OATH (PLAYER_TARGET and CLIENT_HINT are the flags registered by default). (int reg. player) is the player that is registering the hint, to himself (int s) and/or the opponent (int o), with a description called from a string defined in (str). Additional resets, other than the default RESET_PHASE+PHASE_END, can be passed in (int reset_code) and its reset count (int ct).
---
aux.ReincarnationCheckTarget(Effect e, Card c) -> bool
Auxiliary function for "Salamangreat" Reincarnation procedure. Returns if (card c) is either a Fusion, Ritual or a Link.
---
aux.ReincarnationCheckValue(Effect e, Card c) -> function
Auxiliary function for "Salamangreat" Reincarnation procedure. Registers CARD_SALAMANGREAT_SANCTUARY as flag  to (card c) if it is either a Link, Fusion or Ritual and has among its materials a card with the same ID as (card c).
---
aux.ReincarnationRitualFilter(Effect e, Card c) -> bool
Auxiliary filter for "Salamangreat" Reincarnation procedure to handle the rituals.
---
aux.RelCheckGoal(int player, Group sg, Group exg, Group mustg, int count, int min, function specialchk, any ...) -> bool
(To be added)
---
aux.RelCheckRecursive(Card c, int player, Group sg, Group mg, Group exg, Group mustg, int count, int min, function specialchk, any ...) -> bool
(To be added)
---
aux.ReleaseCheckMMZ(Group sg, int player) -> bool
(To be added)
---
aux.ReleaseCheckSingleUse(Group sg, int player, Group exg) -> bool
(To be added)
---
aux.ReleaseCheckTarget(Group sg, int player, Group exg, Group dg) -> bool
(To be added)
---
aux.ReleaseCostFilter(Card c, function f, any ...) -> bool
(To be added)
---
aux.ReleaseNonSumCheck(Card c, int player, Effect e) -> bool
Auxiliary function called by "Duel.CheckReleaseGroupSummon" and Duel.SelectReleaseGroupSummon".
---
aux.RemainFieldCost(Effect e, int tp, Group|nil eg, int ep, int ev, Effect re, int r, int rp, int chk) -> bool|void
Costs that is used in cards that stay on the field if they finish resolving. (e.g. Kunai with Chain, Different Dimension Burial)
---
aux.RemainFieldDisabled(Effect e, int tp, Group|nil eg, int ep, int ev, Effect re, int r, int rp) -> 
(To be added)
---
aux.RemoveUntil(Card|Group cg, int|nil pos, int reason, int phase, Effect e, int player, function oper, function|nil cond) -> Effect
Banishes card(s) and performs an operation to them in a given phase (usually return them to their current location). Returns the effect that would perform the operation if a card is successfully banished, otherwise returns nil. Parameters: - Card|Group card_or_group: the cards to banish, - int|nil pos: the cards' position when banished. `nil` will use their current position, -int reason: the reason for banishing, int phase: the phase when `oper` will be applied to the banished cards, - int flag: a unique integer to be registered as a flag on the affected cards, - Effect e: the effect performing the banishment, - int tp: the player performing the banishment, and will later perform `oper`, - function oper: a function with the signature (rg,e,tp,eg,ep,ev,re,r,rp) where `rg` is the group of cards that can be returned, - function|nil cond: an additional condition function with the signature (rg,e,tp,eg,ep,ev,re,r,rp). `rg` is already checked if it's not empty, - int|nil reset: the reset value. If not passed, the reset will be `RESET_PHASE+phase`. - int|nil reset_count: how many times the reset value must happen. If not passed, the count will be 1. - int|nil hint: a string to show on the affected cards, - int|nil effect_desc: a string to be used as the description of the delayed effect (useful when the same effect registers multiple different delayed effects)
---
aux.ResetEffects(Group g, int eff) -> 
Resets all effects with code (int eff) in a group of cards defined (Group g).
---
aux.ritlimit(Effect e, Effect se, int sp, int st) -> bool
SPSUMMON condition "Must be Ritual Summoned"
---
aux.RitualCheckAdditionalLevel() -> function
(To be added)
---
aux.RitualProcedure() -> function
Function used by the ritual procedure. An alias of the Ritual table.
---
aux.SecurityForceCost() -> function
(To be added)
---
aux.SecurityTarget() -> function
Target function "S-Force" archetype's "facing", aka, card in the same column as an "S-Force" monster.
---
aux.SelectEffect(int player, any ...) -> int|nil
Function deprecated since version 40.0.0. Use "Duel.SelectEffect" instead
---
aux.SelectUnselectGroup(Group g, Effect e, int tp, int minc, int maxc, SubgroupCheck|nil rescon, int chk) -> bool
Checks if a group contains a subgroup that fulfills a function.
---
aux.SelectUnselectLoop(any ...) -> bool|Group
Auxiliary function used by the SelectUnselectGroup function only
---
aux.SelfBanishCost(Effect e, int tp, Group eg, int ep, Group ev, Effect re, int r, int rp, int chk) -> bool
A baseline [cost function](/api/types/EffectCost) used for effects that banish the activating card itself as cost, such as `You can banish this card (you control/from.../etc); ...` (e.g. "Destiny HERO - Malicious").
---
aux.SelfDiscardCost(Effect e, int tp, Group eg, int ep, Group ev, Effect re, int r, int rp, int chk) -> bool
A baseline [cost function](/api/types/EffectCost) used for effects that discard the activating card itself as cost, such as `You can discard this card; ...` (e.g. "Ash Blossom & Joyous Spring").
---
aux.SelfDiscardToGraveCost(Effect e, int tp, Group eg, int ep, Group ev, Effect re, int r, int rp, int chk) -> bool
A baseline [cost function](/api/types/EffectCost) used for effects that discard the activating card itself to the GY as cost, such as `You can discard this card to the GY; ...` (e.g. "D.D. Crow").
---
aux.SelfToDeckCost(Effect e, int tp, Group eg, int ep, Group ev, Effect re, int r, int rp, int chk) -> bool
A baseline [cost function](/api/types/EffectCost) used for effects that shuffle the activating card itself to the Main Deck as cost, such as `You can shuffle this card (you control/from.../etc) into the Deck; ...` (e.g. "Rescue Ferret").
---
aux.SelfToExtraCost(Effect e, int tp, Group eg, int ep, Group ev, Effect re, int r, int rp, int chk) -> bool
A baseline [cost function](/api/types/EffectCost) used for effects that return the activating card itself to the Extra Deck as cost, such as `You can return this card (you control/from.../etc) to the Extra Deck; ...` (e.g. "Gladiator Beast Gyzarus").
---
aux.SelfToGraveCost(Effect e, int tp, Group eg, int ep, Group ev, Effect re, int r, int rp, int chk) -> bool
A baseline [cost function](/api/types/EffectCost) used for effects that send the activating card itself to the GY as cost, such as `You can send this card (you control/from.../etc) to the GY; ...` (e.g. "Rescue Cat").
---
aux.SelfToHandCost(Effect e, int tp, Group eg, int ep, Group ev, Effect re, int r, int rp, int chk) -> bool
A baseline [cost function](/api/types/EffectCost) used for effects that return the activating card itself to the hand as cost, such as `You can return this card (you control/from.../etc) to the/your hand; ...` (e.g. "Sauravis, the Ancient and Ascended").
---
aux.SelfTributeCost(Effect e, int tp, Group eg, int ep, Group ev, Effect re, int r, int rp, int chk) -> bool
A baseline [cost function](/api/types/EffectCost) used for effects that Tribute the activating card itself as cost, such as `You can Tribute this card (you control/from.../etc); ...` (e.g. "Kaibaman").
---
aux.seqmovcon(any e, any tp, any eg, any ep, any ev, any re, any r, any rp) -> function
Condition for effects that make the monster change its current sequence/column.
---
aux.seqmovop(any e, any tp, any eg, any ep, any ev, any re, any r, any rp) -> function
Operation for effects that make the monster change its current sequence/column.
---
aux.seqmovtg(any e, any tp, any eg, any ep, any ev, any re, any r, any rp) -> function
(To be added)
---
aux.seqmovtgop(any e, any tp, any eg, any ep, any ev, any re, any r, any rp) -> function
(To be added)
---
aux.SetSkillOp(any coverNum, any drawless, any skillcon, any skillop, any countlimit, any efftype) -> Effect
(To be added)
---
aux.SetUnionState(Card c) -> 
See proc_union.lua.
---
aux.SetVrainsSkillOp(any ...) -> function
(To be added)
---
aux.SpElimFilter(Card c, bool mustbefaceup, bool includemzone) -> bool
Spirit Elimination check to (Card c). It checks if controller is affected by Spirit Elimination. If so, it will only filter in the Monster Zone, otherwise in Graveyard. (bool mustbefaceup) means the filter is not generic (e.g. Banish 1 Dragon-Type monster) opposed to banish 1 monster. (bool includemzone) when set to true will check LOCATION_MZONE by default as opposed to filtering LOCATION_MZONE and LOCATION_GRAVE depending on affected by Spirit Elimination.
---
aux.SpiritReturnCondition(any ...) -> function
(To be added)
---
aux.SpiritReturnOperation(any e, any tp, any eg, any ep, any ev, any re, any r, any rp) -> 
Function deprecated since version 40.0.0. Use "Spirit.SummonRegister"
---
aux.SpiritReturnReg(any e, any tp, any eg, any ep, any ev, any re, any r, any rp) -> 
Function deprecated since version 40.0.0. Use "Spirit.SummonRegister"
---
aux.SpiritReturnTarget(any ...) -> 
(To be added)
---
aux.StardustCost(any ...) -> 
(To be added)
---
aux.Stringid(int code, int n) -> int
Returns the description code using the database entry's code (int code) and from the nth position (int position) which can be 0-15 corresponding to the str in the database which are from str1 to str16
---
aux.sumlimit(int sumtype) -> bool
helper function called by the various auxiliary function used as special summon conditions
---
aux.summonproc(any ...) -> bool
(To be added)
---
aux.sumreg(Effect e, int tp, Group eg, int ep, int ev, Effect re, int r, int rp) -> 
Used as SetOperation which registers a FlagEffect to cards in the event group with the same OriginalCode as itself
---
aux.SynchroProcedure(any ...) -> function
(To be added)
---
aux.synlimit(Effect e, Effect se, int sp, int st) -> bool
SPSUMMON condition "Must be Synchro Summoned"
---
aux.tableAND(any ...) -> table
(To be added)
---
aux.tableOR(any ...) -> table
(To be added)
---
aux.TargetBoolFunction(function f, any ...) -> bool
Used in SetTarget filters (with parameters (e,c)) to check a function and its (...) parameters
---
aux.TargetEqualFunction(function f, int value, any ...) -> bool
Used in SetTarget filters (with parameters (e,c)) to check a function and its (...) parameters is equal to the inputted (int value).
---
aux.TatsunecroFilter(Card c) -> bool
Returns is Card c has "3096468" as flag effect. Used in the Synchro summon procedure
---
aux.tgoval(Effect e, Effect re, int rp) -> bool
filter for EFFECT_CANNOT_BE_EFFECT_TARGET, "cannot be targeted by your opponent's card effects"
---
aux.thoeSend(Card c) -> 
Sends (card c) to the grave. Function added to be used with aux.ToHandOrElse
---
aux.ToHandOrElse(Card|Group cg, int player, CardFilter check, CardFilter oper, int str, any ...) -> any
Makes a player either add cards to the hand or perform an alternative action.
---
aux.TRUE() -> bool
Function that returns true. Can be used to return a whole group of cards in a certain location
---
aux.UnionFilter(any ...) -> function
(To be added)
---
aux.UnionLimit(any ...) -> function
(To be added)
---
aux.UnionOperation(any ...) -> function
(To be added)
---
aux.UnionReplace(any ...) -> function
(To be added)
---
aux.UnionSumOperation(any ...) -> function
(To be added)
---
aux.UnionSumTarget(any ...) -> function
(To be added)
---
aux.UnionTarget(any ...) -> function
(To be added)
---
aux.ValuesReset() -> 
(To be added)
---
aux.WelcomeLabrynthTrapDestroyOperation(any ...) -> function
(To be added)
---
aux.WitchcrafterDiscardAndReleaseCost(any ...) -> function
(To be added)
---
aux.WitchcrafterDiscardCost(any f, int minc, int maxc) -> 
Auxiliary function for the discard cost of "Witchcrafter" monsters. Performs the actual discard part, considering a minimum (minc) and maximum (maxc) amount of cards to discard. It also handles cards with EFFECT_WITCHCRAFTER_REPLACE, setting the reason for REASON_COST for those, or REASON_COST+REASON_DISCARD if a card is sent from hand instead.
---
aux.xyzlimit(Effect e, Effect se, int sp, int st) -> bool
SPSUMMON condition "Must be Xyz Summoned"
---
aux.XyzProcedure(any ...) -> function
to be added
---
aux.ZoneCheckFunc(Card c, int player, int zone) -> int
Auxiliary function called by "Duel.CheckReleaseGroupSummon" and Duel.SelectReleaseGroupSummon".
---
aux.zptcon(any filter) -> bool
Used as condition for effects that check "if a [filter] monster is Special Summoned to a zone this card points to". Includes non-trivial handling of self-destructing Burning Abyss monsters. tp is passed to check control.
---
aux.zptfilter(any filter) -> bool
Used as filter for effects that check "if [filter] monster is Special Summoned to a zone this card points to". Also includes non-trivial handling of self-destructing effects of "Burning Abyss" monsters.
---
aux.zptgroup(Group eg, function filter, Card c, int tp) -> Group
Filter for "If a (function filter) monster is Special Summoned to a zone this card points to". Includes non-trivial handling of self-destructing Burning Abyss monsters
---
aux.zptgroupcon(Group eg, function filter, Card c, int tp) -> bool
(To be added)
---
aux.ZWEquipLimit(any ...) -> function
to be added
---
AddCannotBeSpecialSummoned(Card c) -> Effect
Creates and registers an [Effect](/api/types/Effect) to a monster card that applies a "Cannot be Special Summoned" Summoning condition to it
---
AddCenterToSideEffectHandler(Card c, Effect eff) -> 
Grants an effect to a center Maximum Monster's [L] and [R] pieces. Primarily used to share protection effects.
---
AddCounter(Card c, int countertype, int count, bool checklimits) -> bool
Places any number of counters of the specified type to a card.
---
AddDoubleTribute(Card c, int id, CardFilter otfilter, TargetFilterFunction eftg, int resets, int ...) -> 
Adds an effect to a card that allows using cards as double (or triple) tributes in Rush Duels.
---
AddMaximumAtkHandler(Card c) -> 
Adds an Effect to a Card that changes its original ATK to its Maximum ATK when in Maximum Mode. The Maximum ATK is obtained from the card's metatable.
---
AddMonsterAttribute(Card c, int extra_type, int attribute, int race, int level, int atk, int def) -> 
Transforms the provided card into a monster. Must be completed by calling [`Card.AddMonsterAttributeComplete`](/api/functions/Card/AddMonsterAttributeComplete) after the card has been moved to the Monster Zone. The card's properties reset to their original values when it is flipped face-down, becomes attached as Xyz material, or sent to the hand, Deck, GY, or banishment.
---
AddMonsterAttributeComplete(Card c) -> 
Used in conjunction with [`Card.AddMonsterAttribute`](/api/functions/Card/AddMonsterAttribute) after the card has been moved to the Monster Zone to complete the transformation of the provided card into a monster.
---
AddMustBeFusionSummoned(Card c) -> Effect
Creates and registers an [Effect](/api/types/Effect) to a monster card that applies a "Must be Fusion Summoned" Summoning condition to it
---
AddMustBeLinkSummoned(Card c) -> Effect
Creates and registers an [Effect](/api/types/Effect) to a monster card that applies a "Must be Link Summoned" Summoning condition to it
---
AddMustBePendulumSummoned(Card c) -> Effect
Creates and registers an [Effect](/api/types/Effect) to a monster card that applies a "Must be Pendulum Summoned" Summoning condition to it
---
AddMustBeRitualSummoned(Card c) -> Effect
Creates and registers an [Effect](/api/types/Effect) to a monster card that applies a "Must be Ritual Summoned" Summoning condition to it
---
AddMustBeSpecialSummoned(Card c) -> Effect
Creates and registers an [Effect](/api/types/Effect) to a monster card that applies a "Must be Special Summoned" Summoning condition to it
---
AddMustBeSpecialSummonedByCardEffect(Card c) -> Effect
Creates and registers an [Effect](/api/types/Effect) to a monster card that applies a "Must be Special Summoned by card effect" Summoning condition to it
---
AddMustBeSpecialSummonedByDarkFusion(Card c) -> Effect
Creates and registers an [Effect](/api/types/Effect) to a monster card that applies a "Must be Special Summoned by Dark Fusion" Summoning condition to it
---
AddMustBeSynchroSummoned(Card c) -> Effect
Creates and registers an [Effect](/api/types/Effect) to a monster card that applies a "Must be Synchro Summoned" Summoning condition to it
---
AddMustBeXyzSummoned(Card c) -> Effect
Creates and registers an [Effect](/api/types/Effect) to a monster card that applies a "Must be Xyz Summoned" Summoning condition to it
---
AddMustFirstBeFusionSummoned(Card c) -> Effect
Creates and registers an [Effect](/api/types/Effect) to a monster card that applies a "Must first be Fusion Summoned" Summoning condition to it
---
AddMustFirstBeLinkSummoned(Card c) -> Effect
Creates and registers an [Effect](/api/types/Effect) to a monster card that applies a "Must first be Link Summoned" Summoning condition to it
---
AddMustFirstBePendulumSummoned(Card c) -> Effect
Creates and registers an [Effect](/api/types/Effect) to a monster card that applies a "Must first be Pendulum Summoned" Summoning condition to it
---
AddMustFirstBeRitualSummoned(Card c) -> Effect
Creates and registers an [Effect](/api/types/Effect) to a monster card that applies a "Must first be Ritual Summoned" Summoning condition to it
---
AddMustFirstBeSynchroSummoned(Card c) -> Effect
Creates and registers an [Effect](/api/types/Effect) to a monster card that applies a "Must first be Synchro Summoned" Summoning condition to it
---
AddMustFirstBeXyzSummoned(Card c) -> Effect
Creates and registers an [Effect](/api/types/Effect) to a monster card that applies a "Must first be Xyz Summoned" Summoning condition to it
---
AddNoTributeCheck(any c, any id, any stringid, any rangeP1, any rangeP2) -> 
to be added. Available in proc_maximum.lua
---
AddPiercing(any c, any reset, any rc, any condition, any properties) -> 
to be added. Available in proc_maximum.lua
---
AddSetcodesRule(Card c, int code, any copyable, int ...) -> EffectArray
Creates and registers [`EFFECT_ADD_SETCODE`](/api/constants/EffectCode/EFFECT_ADD_SETCODE) effects to add any number of archetypes to a card.
---
AddSideMaximumHandler(any c, any eff) -> 
Rush related function
---
Alias(Card c) -> int
Returns a card's alias.
---
AnnounceAnotherAttribute(Card c, int player) -> int
Makes a player declare an attribute other than the ones a card currently has.
---
AnnounceAnotherRace(Card c, int player) -> int
Makes a player declare a race other than the ones a card currently has.
---
AssumeProperty(Card c, int assume_type, int assume_value) -> 
Temporarily assumes a property for a card. The card will be considered as having this property as long as the function in the scope surrounding this function's call is still processing.
---
Attack(Card c) -> int
Returns a card's original ATK.
---
Attribute(Card c) -> int
Returns the card's original attribute(s).
---
CanAttack(Card c) -> bool
Checks if a card can declare an attack.
---
CanBeDoubleTribute(any c, any ...) -> bool
to be added. Available in proc_maximum.lua
---
CancelCardTarget(Card c, Card tc) -> 
Makes a card stop targeting another card.
---
CancelToGrave(Card c, bool cancel) -> 
Changes the behavior of the default rule in which certain types of cards are sent to the GY when they resolve (e.g. Normal Spells, Quick-Play Spells, Ritual Spells, Normal Traps, and Counter Traps) and others stay on the field (e.g. Field Spells, Pendulum Spells, Continuous Spells, and Continuous Traps).
---
CanChainAttack(Card c, int attackcount, bool on_monsters_only) -> bool
Checks if a card can make a number of attacks in a row.
---
CanGetPiercingRush(any c) -> bool
Rush related function
---
CanSummonOrSet(Card c, bool ignore_count, Effect|nil e, int min) -> bool
Checks if a card can be Normal Summoned or Set.
---
CheckActivateEffect(Card c, bool neglect_con, bool neglect_cost, bool copy_info) -> Effect
Checks a card (Card c)'s EFFECT_TYPE_ACTIVATE effect while checking for whether it can be activated. Setting the neglect_con parameter to true will ignore the condition. Setting the neglect_cost parameter to true will ignore the cost verification. If the copy_info parameter is false OR if the effect's code is EVENT_FREE_CHAIN, then the function returns the effect that is being checked, if it can be activated or false, if it cannot be activated. If copy_info is true, additionally returns the activated effect's supposed info, which usually are eg,ep,ev,r,re,rp (event group, event player, event value, reason effect, reason, reason player)
---
CheckAdjacent(Card c) -> bool
Returns if either of the sequences next to the card c's sequence is available. Already handles the Extra monster zone (sequence > 4). Limited to Monster Zones.
---
CheckEquipTarget(Card c1, Card c2) -> bool
Checks if a card can be equipped to another.
---
CheckEquipTargetRush(any equip, any monster) -> bool
to be added. Available in proc_maximum.lua
---
CheckFusionMaterial(Card c, Group g, Card|nil gc, int chkf) -> bool
Check if g contains a set of fusion material that c needs [must contain gc]. Check the Condition function for the effect of EFFECT_FUSION_MATERIAL according to the type of c
---
CheckFusionSubstitute(Card c, Card fc) -> bool
Checks if a card (Card c) can be treated as a substitute for one of the listed fusion materials used by Card fc).
---
CheckRemoveOverlayCard(Card c, int player, int count, int reason) -> bool
Checks if the player (int player) can remove a number (int count) of Xyz materials from a Card c for a specific reason (int reason)
---
CheckUnionTarget(any c, any eqc) -> bool
to be added. Available in libcard.cpp
---
CheckUniqueOnField(Card c, int check_player, int check_location, Card icard) -> bool
Checks if (Card c) going to a player's (int player) field would violate the "Can only control 1" clause. If (int check_location) is provided, checks for the uniqueness in that location only. (Card icard) is the ignored card.
---
ClearEffectRelation(Card c) -> 
Clears any relation between a card (Card c) and all effects and chains
---
Code(Card c) -> int
Returns a card's current passcode/ID.
---
CompleteProcedure(Card c) -> 
Makes a card (Card c) be considered that it's Summon procedure is complete
---
CopyEffect(Card c, int code, int reset_flag, int reset_count) -> int
Temporarily adds to a card the effects of the card with the specified id, that reset according to the provided reset flags.
---
Cover(Card c) -> int
Skill related function
---
CreateEffectRelation(Card c, Effect e) -> 
Creates a relation between a card (Card c) and an effect (Effect e)
---
CreateRelation(Card c1, Card c2, int reset_flag) -> 
Creates a relation between the first card (Card c1) and the second card (Card c2), which will be reset when the first card hits the reset flag
---
Defense(Card c) -> int
Returns a card's original DEF.
---
EnableCounterPermit(Card c, int countertype, int location) -> 
Enables the card to hold a counter that requires permissions. Refer to the [counter guide](https://projectignis.github.io/scrapi-book/guides/general/counter.html) for details on counter permissions.
---
EnableGeminiState(Card c) -> 
Enables the Gemini effect of a card (Card c). To be deprecated. Use EnableGeminiStatus instead
---
EnableGeminiStatus(Card c) -> 
Enables the Gemini effect of a card (Card c). Alias to Card.EnableGeminiState
---
EnableReviveLimit(Card c) -> 
Makes a card (Card c) unsummonable except with its own procedure, or after its Summon procedure is complete (for example, all extra deck monsters and Ritual monsters)
---
EnableUnsummonable(Card c) -> 
Makes a card (Card c) unsummonable except with its own procedure
---
EquipByEffectAndLimitRegister(Card c, Effect e) -> bool
(To be added)
---
EquipByEffectLimit(Card c, Effect e, int tp, Card tc, int|nil code, bool mustbefaceup) -> bool
Equips (Card tc) to (Card c). Adding a (int code) will register that code as flag effect to the equipped card  (bool mustbefaceup) defines if the card to be equipped is required to be face-up.
---
FromLuaRef(int ref) -> Card
Returns a Card object from a given lua reference. The function errors out if the reference is invalid or does not refer to a Card object.
---
GetActivateEffect(Card c) -> Effect
Gets a card's activation effects (i.e., effects with [`EFFECT_TYPE_ACTIVATE`](/api/constants/EffectType/EFFECT_TYPE_ACTIVATE) in their effect type).
---
GetAllCounters(Card c) -> table
Gets all counters a card currently has.
---
GetAttack(Card c) -> int
Gets the current ATK of a card.
---
GetAttackableTarget(Card c) -> Group
Gets a card's (Card c) valid attack targets
---
GetAttackAnnouncedCount(Card c) -> int
Gets the number of attacks declared by Card c, set to 0 before drawing and when starting second Battle Phase
---
GetAttackedCount(Card c) -> int
Gets the number of successful(not negated) attacks done by Card c, set to 0 before drawing and when starting second Battle Phase
---
GetAttackedGroup(Card c) -> Group
Gets a group of cards attacked by Card c, cleared before drawing and when starting second Battle Phase
---
GetAttackedGroupCount(Card c) -> int
Gets the number of cards attacked by Card c, set to 0 before drawing and when starting second Battle Phase
---
GetAttribute(Card c) -> int
Gets the current attribute(s) of a card.
---
GetBaseAttack(Card c) -> int
Gets the original ATK of a card. This might differ from the printed ATK of the card due to effects that change original ATK. Use [`Card.GetTextAttack`](/api/functions/Card/GetTextAttack) if you need the printed ATK instead.
---
GetBaseDefense(Card c) -> int
Gets the original DEF of a card. This might differ from the printed DEF of the card due to effects that change original DEF. Use [`Card.GetTextDefense`](/api/functions/Card/GetTextDefense) if you need the printed DEF instead.
---
GetBattledGroup(Card c) -> Group
Gets a Group of cards that are battled (all the attacking and the attacked cards), cleared at predraw and when starting second Battle Phase
---
GetBattledGroupCount(Card c) -> int
Gets the count of cards that has battled (all the attacking and the attacked cards)
---
GetBattlePosition(Card c) -> int
Returns the battle position of a monster at the start of the Damage Step.
---
GetBattleTarget(Card c) -> Card
Gets a card's (Card c) current battle target
---
GetCardEffect(Card c, int code) -> Effect
Returns all the effects being applied to a card, such as by Equip and Field Effects. This also includes the card's own [Single](/api/constants/EffectType/EFFECT_TYPE_SINGLE) effects. For effects registered or being granted to a card, use [`Card.GetOwnEffects`](/api/functions/Card/GetOwnEffects).
---
GetCardID(Card c) -> int
Returns the internal card ID that "c" has. This will be unique per card and won't change during the course of the duel.
---
GetCardTarget(Card c) -> Group
Gets the group of cards that a card (Card c) is assigned targets to
---
GetCardTargetCount(Card c) -> int
Gets the number of targets that a card (Card c) is assigned to
---
GetCode(Card c) -> int
Returns the current code (ID/name) of the card "c".
---
GetColumnGroup(Card c, int|nil left, int|nil right) -> Group
Returns a group with all the cards that are in the same column as "c". If "left" or "right" are provided, the returned group will also include the cards from the N columns on the left or right of "c" respectively, where N is the number passed for the "left" or "right" parameter.
---
GetColumnGroupCount(Card c, int|nil left, int|nil right) -> int
Returns the number of cards that are in the same column as "c". If "left" or "right" are provided, the returned number will also include the cards from the N columns on the left or right of "c" respectively, where N is the number passed for the "left" or "right" parameter.
---
GetColumnZone(Card c, int loc, int|nil left, int|nil right, int cp) -> int
Returns all the zones in the same column as "c" that are part of the location "loc". If "cp" is provided, the returned zones will only include the ones that belong to player "cp". If "left" or "right" are provided, the returned zones will also include the ones from the N columns on the left or right of "c" respectively, where N is the number passed for the "left" or "right" parameter.
---
GetControler(Card c) -> int
Returns the controller of "c".
---
GetCounter(Card c, int countertype) -> int
Gets the number of counters of a certain type a card has.
---
GetDefense(Card c) -> int
Gets the current DEF of a card.
---
GetDestination(Card c) -> int
Returns the location a card would be sent to (e.g. when it would be destroyed).
---
GetEffectCount(Card c, int code) -> int
Gets the amount of an Effect (EFFECT_x) registered to a Card (Card c)
---
GetEquipCount(Card c) -> int
Gets the number of cards equipped to a Card (Card c)
---
GetEquipGroup(Card c) -> Group
Gets a Group of Cards equipped to a Card (Card c)
---
GetEquipTarget(Card c) -> Card
Gets the Card that a Card (Card c) is equipped to
---
GetFieldID(Card c) -> int
Returns a card's current location ID, a value assigned to a card whenever it changes locations.
---
GetFirstCardTarget(Card c) -> Card
Gets the first among the target card of (Card c). A bit faster than Card.GetCardTarget(Card c):GetFirst()
---
GetFlagEffect(Card c, int code) -> int
Returns the amount of flag effects with (int code) as the EffectCode that are registered to a card (Card c)
---
GetFlagEffectLabel(Card c, int code) -> int
Gets the integer labels to the flag effect attached to a card (Card c) with (int code) as the EffectCode, returns nil if there is no integer label.
---
GetFreeLinkedZone(Card c) -> int
Returns all the zones that "c" points to that are not occupied by a card.
---
GetLeaveFieldDest(Card c) -> int
Returns the location a card would be sent to when it leaves the field, taking into account effects that would redirect it (e.g. "but banish it if it leaves the field").
---
GetLeftScale(Card c) -> int
Returns the current left Pendulum Scale of "c". (Returns 0 if it has no Pendulum Scale.)
---
GetLevel(Card c) -> int
Returns the current Level of "c". (Returns 0 if it has no Level, e.g. Xyz/Link.)
---
GetLink(Card c) -> int
Returns the current Link Rating of "c". (Returns 0 if it has no Link Rating.)
---
GetLinkedGroup(Card c) -> Group
Returns a group with all the cards that "c" points to. (Returns an empty group if it does not point to any cards.)
---
GetLinkedGroupCount(Card c) -> int
Returns the number of cards that "c" points to.
---
GetLinkedZone(Card c, int cp) -> int
Returns all the zones that "c" points to (on the field of player "cp").
---
GetLinkMarker(Card c) -> int
Returns the combined LinkMarkers Card c has. The return value can be bitmasked to extract specific markers.
---
GetLocation(Card c) -> int
Returns the location of "c".
---
GetLuaRef(Card c) -> int
Returns an integer representing the internal value used by lua to access the Card c.
---
GetMaterial(Card c) -> Group
Gets the material which was used as cost for a Card (Card c)
---
GetMaterialCount(Card c) -> int
Gets the number of materials used as cost for a Card (Card c)
---
GetMaximumAttack(any c) -> int
(To be added)
---
GetMetatable(Card c, int current_code) -> table
Similar to Duel.GetMetatable, but if current_code is true it behaves as if it were Duel.GetMetatable(c:GetCode()), otherwise it returns the __index field of the card's object (this difference only matters when a card's id is not its original one, like when copying names via effect or having an alias)
---
GetMutualLinkedGroup(Card c) -> Group
Returns a group with all the cards that are co-linked with "c". (Returns an empty group if there are none.)
---
GetMutualLinkedGroupCount(Card c) -> int
Returns the number of cards that are co-linked with "c".
---
GetMutualLinkedZone(Card c, int cp) -> int
Gets all zones that (Card c) points to as part of a co-Link, that belong to player (int cp)
---
GetOriginalAttribute(Card c) -> int
Returns the original Attribute of "c".
---
GetOriginalCode(Card c) -> int
Returns the original printed code (ID/name) of the card "c".
---
GetOriginalCodeRule(Card c) -> int
Returns the original code (ID/name) of the card "c" while taking into account name clauses/alias (used for the "original name" wording).
---
GetOriginalLeftScale(Card c) -> int
Returns the original left Pendulum Scale of "c". (Returns 0 if it has no Pendulum Scale.)
---
GetOriginalLevel(Card c) -> int
Returns the original Level of "c". (Returns 0 if it has no Level, e.g. Xyz/Link.)
---
GetOriginalRace(Card c) -> int
Returns the original Monster Type of "c".
---
GetOriginalRank(Card c) -> int
Returns the original Rank of "c". (Returns 0 if it has no Rank.)
---
GetOriginalRightScale(Card c) -> int
Returns the original right Pendulum Scale of "c". (Returns 0 if it has no Pendulum Scale.)
---
GetOriginalSetCard(Card c) -> int
Returns the original archetype(s) that "c" is a part of.
---
GetOriginalType(Card c) -> int
Returns the original CardType (Monster/Spell/Trap) of "c".
---
GetOverlayCount(Card c) -> int
Gets the number of cards overlayed to a Card (Card c)
---
GetOverlayGroup(Card c) -> Group
Gets the cards overlayed to a Card (Card c)
---
GetOverlayTarget(Card c) -> Card
Gets the card that (Card c) is an overlay of
---
GetOwnEffects(Card c) -> Effect
Returns all the effects registered to a card. This includes effects being [granted](/api/constants/EffectType/EFFECT_TYPE_GRANT) to it. For effects being applied to a card, such as Equip Effects and Field Effects, use [`Card.GetCardEffect`](/api/functions/Card/GetCardEffect).
---
GetOwner(Card c) -> int
Returns the [owner](https://yugipedia.com/wiki/Owner) of a card.
---
GetOwnerTarget(Card c) -> Group
Gets a group of cards (including equips) that a card (Card c) is a target of
---
GetOwnerTargetCount(Card c) -> int
Gets the number of cards (including equips) that a card (Card c) is a target of
---
GetPosition(Card c) -> int
Returns the current position of "c".
---
GetPreviousAttackOnField(Card c) -> int
Returns the ATK that "c" had when it was on the field.
---
GetPreviousAttributeOnField(Card c) -> int
Returns the Attribute that "c" had when it was on the field.
---
GetPreviousCodeOnField(Card c) -> int
Returns the code/ID that "c" had when it was on the field.
---
GetPreviousControler(Card c) -> int
Returns the previous controller of "c".
---
GetPreviousDefenseOnField(Card c) -> int
Returns the DEF that "c" had when it was on the field.
---
GetPreviousEquipTarget(Card c) -> Card
Gets the Card that a Card (Card c) was equipped to
---
GetPreviousLevelOnField(Card c) -> int
Returns the Level that "c" had when it was on the field.
---
GetPreviousLocation(Card c) -> int
Returns the previous location of "c".
---
GetPreviousPosition(Card c) -> int
Returns the previous position of "c".
---
GetPreviousRaceOnField(Card c) -> int
Returns the Monster Type that "c" had when it was on the field.
---
GetPreviousRankOnField(Card c) -> int
Returns the Rank that "c" had when it was on the field.
---
GetPreviousSequence(Card c) -> int
Gets the sequence/order of the location of (Card c)
---
GetPreviousSetCard(Card c) -> int
Returns the archetype(s) that "c" was part of previously.
---
GetPreviousTypeOnField(Card c) -> int
Returns the CardType that "c" had when it was on the field.
---
GetRace(Card c, Card|nil scard, int sumtype, int playerid) -> int
Returns the current Monster Type of "c" (if it is to be used as material for "scard" with SummonType "sumtype" by player "playerid").
---
GetRank(Card c) -> int
Returns the current Rank of "c". (Returns 0 if it has no Rank.)
---
GetRealFieldID(Card c) -> int
Returns a card's unique duel ID, a value assigned to a card at the start of the duel and never changes.
---
GetReason(Card c) -> int
Returns the reason for an event that happened to "c" (e.g. cost, effect).
---
GetReasonCard(Card c) -> Card
Returns the card which is the reason that an event happened to "c".
---
GetReasonEffect(Card c) -> Effect
Returns the effect which is the reason for an event that happened to "c".
---
GetReasonPlayer(Card c) -> int
Returns the player that is the reason for an event that happened to "c".
---
GetRightScale(Card c) -> int
Returns the current right Pendulum Scale of "c". (Returns 0 if it has no Pendulum Scale.)
---
GetRitualLevel(Card c, Card rc) -> int
Returns the Level of "c" if it would be Tributed for the Ritual Summon of "rc".
---
GetScale(Card c) -> int
Returns the scale value that (Card c) has. If c is not TYPE_PENDULUM, returns 0. Runs on the assumption that both scales have the same value, returning the value for the left scale if the card is not on the Pendulum Zone. For cards with different values for the scales (no official card at the moment), returns the left scale if the card is in the left Pendulum Zone or the right scale, if it is in the right Pendulum Zone.
---
GetSequence(Card c) -> int
Gets the sequence/order of the location of (Card c)
---
GetSetCard(Card c, Card|nil scard, int sumtype, int playerid) -> int
Returns the archetype(s) that "c" has (if it is to be used as material for "scard" with SummonType "sumtype" by player "playerid").
---
GetSummonLocation(Card c) -> int
Returns the location that "c" was summoned from.
---
GetSummonPlayer(Card c) -> int
Returns the player that summoned "c".
---
GetSummonType(Card c) -> int
Gets the type in which (Card c) was Summoned
---
GetSynchroLevel(Card c, Card sc) -> int
Returns the Level of "c" if it would be used as a Synchro Material for "sc".
---
GetTextAttack(Card c) -> int
Gets the printed ATK of a card. This might differ from the original ATK of the card due to effects that change original ATK. Use [`Card.GetBaseAttack`](/api/functions/Card/GetBaseAttack) if you need the original ATK instead.
---
GetTextDefense(Card c) -> int
Gets the printed DEF of a card. This might differ from the original DEF of the card due to effects that change original DEF. Use [`Card.GetBaseDefense`](/api/functions/Card/GetBaseDefense) if you need the original DEF instead.
---
GetToBeLinkedZone(Group g, Card c, int tp, bool clink, bool emz) -> int
Iterates group g with "Card.GetToBeLinkedZone" operations.
---
GetTributeRequirement(Card c) -> int
Give a min and a max tribute requirement of a card
---
GetTurnCounter(Card c) -> int
Gets the turn counter of a Card (Card c)
---
GetTurnID(Card c) -> int
Returns the turn that "c" was sent/placed to its current location.
---
GetType(Card c, Card|nil scard, int sumtype, int playerid) -> int
Gets the current type of a Card (Card c) where (Card scard) if provided checks the monster that (Card c) would be used as material, (int sumtype) is for checking the SummonType and (int playerid) is the player checking the type.
---
GetUnionCount(Card c) -> int
Gets Amount of Union monsters equipped to a Card (Card c)
---
HasCounter(Card c, int ct) -> bool
Returns `true` if a card currently holds any amount of a specified counter.
---
HasCounters(Card c) -> bool
Returns `true` if a given card currently holds any counter.
---
HasDefense(Card c) -> bool
Returns `true` if a card currently has a defense (DEF) value.
---
HasEquipCard(Card c) -> bool
Returns `true` if a card currently has any number of cards equipped to it.
---
HasFlagEffect(Card c, int id, int ct) -> bool
Returns if (Card c) has a flag with id equal to (int id). If (int ct) is provided, checks if the flags was registered at least that many times.
---
HasLevel(Card c) -> bool
Returns `true` if the given card has a level. 0 and negative levels will count.
---
HasNonZeroAttack(Card c) -> bool
Filter checking if (Card c) is face-up and has more than 0 ATK
---
HasNonZeroDefense(Card c) -> bool
Filter checking if (Card c) is face-up and has more than 0 DEF
---
HasRank(Card c) -> bool
Returns `true` if the given card has a rank.
---
IsAbleToChangeControler(Card c) -> bool
Checks if a card (Card c) is capable of having it's control changed. Checks only whether the card is affected by EFFECT_CANNOT_CHANGE_CONTROL.
---
IsAbleToDeck(Card c) -> bool
Checks if the card c can be returned to the Deck
---
IsAbleToDeckAsCost(Card c) -> bool
Checks if a card (Card c) is able to go to the Deck as a cost
---
IsAbleToDeckOrExtraAsCost(Card c) -> bool
Checks if a card (Card c) is able to go to either the Deck or the Extra Deck as a cost
---
IsAbleToExtra(Card c) -> bool
Checks if the card c can be returned to the Extra Deck
---
IsAbleToExtraAsCost(Card c) -> bool
Checks if a card (Card c) is able to go to the Extra Deck as a cost
---
IsAbleToGrave(Card c) -> bool
Checks if a card (Card c) is able to go to the Graveyard
---
IsAbleToGraveAsCost(Card c) -> bool
Checks if a card (Card c) is able to go to the Graveyard as a cost
---
IsAbleToHand(Card c) -> bool
Checks if the card c can be returned to the hand
---
IsAbleToHandAsCost(Card c) -> bool
Checks if a card (Card c) is able to go to the Hand as a cost
---
IsAbleToRemove(Card c, int player, int pos, int reason) -> bool
Checks if a card (Card c) can be banished. The optional parameters are the player that would banish the card (int player), the position the card must go (int pos) and the reason for the banishing (int reason).
---
IsAbleToRemoveAsCost(Card c, int pos) -> bool
Checks if a card (Card c) is able to be banished as a cost. If (int pos) is provided, checks if it can be banished in that position.
---
IsAllColumn(Card c) -> bool
Checks if all the zones of the column that "c" is on are occupied.
---
IsAttack(Card c, int ...) -> bool
Returns if a card (Card c) has an ATK equal to any of the values passed
---
IsAttackAbove(Card c, int atk) -> bool
Checks if a card (Card c) has ATK equal or above the specified number (int attack), will return false if the card has ? ATK and is not face-up on the field.
---
IsAttackBelow(Card c, int atk) -> bool
Checks if a card (Card c) has ATK equal or below the specified number (int attack), will return false if the card has ? ATK and is not face-up on the field.
---
IsAttackPos(Card c) -> bool
Checks if a card (Card c) is in Attack position
---
IsAttribute(Card c, int attribute, Card|nil scard, int sumtype, int playerid) -> bool
Checks if the Attribute of "c" is "attribute" (if it is to be used as material for "scard" with SummonType "sumtype" by player "playerid").
---
IsAttributeExcept(Card c, int att, Card scard, int sumtype, int playerid) -> bool
Checks if (Card c) has any attribute other than (int att). If the optional parameters are passed, does the checks by calling the equivalent behavior with such parameters with Card.GetAttribute
---
IsBaseAttack(Card c, int atk) -> bool
Returns `true` if a card's original ATK is equal to a given value. Original ATK might differ from the printed ATK of the card due to effects that change original ATK. Use [`Card.IsTextAttack`](/api/functions/Card/IsTextAttack) if you need to check for the printed ATK instead.
---
IsBaseDefense(Card c, int def) -> bool
Returns `true` if a card's original DEF is equal to a given value. Original DEF might differ from the printed DEF of the card due to effects that change original DEF. Use [`Card.IsTextDefense`](/api/functions/Card/IsTextDefense) if you need to check for the printed DEF instead.
---
IsBattleDestroyed(Card c) -> bool
Returns if (Card c) has been confirmed to be destroyed by battle
---
IsBattlePosition(Card c, int pos) -> int
Returns `true` if a card is in a specified battle position at the start of the Damage Step.
---
IsCanAddCounter(Card c, int countertype, int count, bool least_one, int loc) -> bool
Checks if a number (int count) of the specified counter (int countertype) can be added to a card (Card c). When the number of added counter would exceed the limit for that card, if "least_one" is set to true, then it will return true if at least one more counter can be added otherwise it will return false. If location is specified, it returns if it could receive counter when placed on that location.
---
IsCanBeBattleTarget(Card c1, Card c2) -> bool
Checks if a card (Card c1) is a valid battle target for another card (Card c2)
---
IsCanBeDisabledByEffect(Effect e, bool is_monster_effect) -> bool
Checks if a card (Card c) can have its effects negated by an effect (Effect e)
---
IsCanBeEffectTarget(Card c, Effect e) -> bool
Checks if a card (Card c) is targetable by an effect (Effect e)
---
IsCanBeFusionMaterial(Card c, Card fc, int sumtype, int playerid) -> bool
Checks if a card (Card c) can be a Fusion material. If (Card fc) is provided, checks if it can be a Fusion Material for that card. Internally, this is checking if the card does not have status_forbidden and if it is not affected by EFFECT_CANNOT_BE_MATERIAL or EFFECT_CANNOT_BE_FUSION_MATERIAL (to be finished)
---
IsCanBeLinkMaterial(Card c, Card linkc, int player) -> bool
Checks if (Card c) can be used as material for a (Card linkc). "player" is only an additional parameter, is used to send it to the functions as an additional parameter, such as target (function in SetTarget) or operation (function in SetOperation).
---
IsCanBeMaterial(Card c, int summontype) -> bool
Checks if a effect_spsummon_condition is being applied to (Card c) and is false. It is the generic version of Card.IsCanbeXmaterial
---
IsCanBeRitualMaterial(Card c, Card sc, int player) -> bool
Checks if a card (Card c) can be used as Tribute for Ritual Summon. If (Card sc) is provided, checks if it can be used as Tribute for that card's Ritual Summon. If (int player) is provided, checks if it can be used by that player.
---
IsCanBeSpecialSummoned(Card c, Effect e, int sumtype, int sumplayer, bool nocheck, bool nolimit, int sumpos, int target_player, int zone) -> bool
Checks whether a card (Card c) can be Special Summoned by (Effect e), by a summon of type (int sumtype), by player (int sumplayer), in position (int sumpos), to (int target_player)'s side of the field. If (bool nocheck) is true, it will check for a summon ignoring conditions. If (bool nolimit) is true, it will check for a summon ignoring the revive limit.
---
IsCanBeSynchroMaterial(Card c, Card sc, Card tuner, int player) -> bool
Checks if a card (Card c) can be used as a Synchro Material. If (Card sc) is provided, checks if it can be a Synchro Material for that card. If (Card tuner) is also provided, also checks if it can be a Synchro Material if the tuner if that card. If (int player) is provided, checks if it can be used by that player.
---
IsCanBeXyzMaterial(Card c, Card|nil sc, int tp, int reason) -> bool
Checks if a card (Card c) can be used as an Xyz Material. If (Card sc) is provided, checks if it can be used for that card's Xyz Summon. If tp and the reason are provided, checks if that player can attach the card with the given reason.
---
IsCanChangePosition(Card c) -> bool
Checks if the given (Card c) can change its battle position
---
IsCanChangePositionRush(Card c) -> bool
Rush related function. Returns if (Card c) can change its position and is not in Maximum mode
---
IsCanRemoveCounter(Card c, int player, int countertype, int count, int reason) -> bool
Checks if a number (int count) of the specified counter (int countertype) can be removed from a card (Card c), with reason described by (int reason)
---
IsCanTurnSet(Card c) -> bool
Checks if a card (Card c) can be made to face-down position (Set)
---
IsCode(Card c, int ...) -> bool
Checks if "c" has at least 1 code/ID among the "..." list.
---
IsColumn(Card c, int seq, int tp, int loc) -> bool
Checks (Card c) its column using the data of another card which allows checking even if the other card has already left the field using its Sequence (int seq), controller (int tp) and location (int loc)
---
IsContinuousSpell(Card c) -> bool
Checks if a card is currently a [Continuous Spell](https://yugipedia.com/wiki/Continuous_Spell_Card).
---
IsContinuousSpellTrap(Card c) -> bool
Checks if a card is currently a Continuous [Spell](https://yugipedia.com/wiki/Continuous_Spell_Card)/[Trap](https://yugipedia.com/wiki/Continuous_Trap_Card).
---
IsContinuousTrap(Card c) -> bool
Checks if a card is currently a [Continuous Trap](https://yugipedia.com/wiki/Continuous_Trap_Card).
---
IsControler(Card c, int controler) -> bool
Checks if a card (Card c) has player (int p) as it's controller
---
IsControlerCanBeChanged(Card c, bool ign, int zone) -> bool
Checks if a card (Card c) can change control. It returns false in either of these situations:  - c's controller is PLAYER_NONE, - c is not in LOCATION_MZONE, - c is affected by EFFECT_CANNOT_CHANGE_CONTROL, - the opposing player has enough space. If bool ign is true, the monster zone checking is ignored. If int zone is provided, it uses only these zones as reference.
---
IsCounterTrap(Card c) -> bool
Checks if a card is currently a [Counter Trap](https://yugipedia.com/wiki/Counter_Trap_Card).
---
IsDefense(Card c, int ...) -> bool
Returns if a card (Card c) has an DEF equal to any of the values passed.
---
IsDefenseAbove(Card c, int def) -> bool
Checks if a card (Card c) has DEF equal or above the specified number (int defense), will return false if the card has ? DEF and is not face-up on the field.
---
IsDefenseBelow(Card c, int def) -> bool
Checks if a card (Card c) has DEF equal or below the specified number (int defense), will return false if the card has ? DEF and is not face-up on the field.
---
IsDefensePos(Card c) -> bool
Checks if a card (Card c) is in Defense position
---
IsDeleted(Card c) -> bool
Returns if the Card object got internally deleted and remained as dangling reference inside the lua state.
---
IsDestination(Card c, int loc) -> int
Returns `true` if a card would be sent to a given location (e.g. when it would be destroyed).
---
IsDestructable(Card c, Effect e) -> bool
Checks whether a card (Card c) can be destroyed; if an effect (effect e) is given, checks whether the card can be destroyed by that effect
---
IsDifferentAttribute(Card c, int att) -> bool
Deprecated function. Use Card.IsAttributeExcept
---
IsDifferentRace(Card c, int race) -> bool
Returns if (Card c) does not have Race (int race)
---
IsDirectAttacked(Card c) -> bool
Checks if a Card (Card c) has successfully attacked directly
---
IsDisabled(Card c) -> bool
Checks whether a card (Card c) is disabled, equivalent with c:IsStatus(STATUS_DISABLED)
---
IsDiscardable(any Card, int reason) -> bool
Checks if a card (Card c) can be discarded for (int reason).
---
IsDoubleTribute(Card c, int ...) -> bool
Rush related function. Returns false if (Card c) does not have all the flags (int ...) passed as arguments
---
IsEquipCard(Card c) -> bool
Checks if a card is currently a [Equip Card](https://yugipedia.com/wiki/Equip_Card).
---
IsEquipSpell(Card c) -> bool
Checks if a card is currently a [Equip Spell](https://yugipedia.com/wiki/Equip_Spell_Card).
---
IsEvenScale(Card c) -> bool
Returns if a pendulum card (Card c) is a card with an even value for the scale, using Card.GetScale to get the value.
---
IsExactType(Card c, int typ, Card sumc, int sumtype, int player) -> bool
Checks if (Card c)'s type (returned by Card.GetType) is exactly (int typ)
---
IsExtraLinked(Card c) -> bool
Checks if a card is Extra Linked, uses aux.ExtraLinked which obtains 2 Extra Monster Zone monsters of each player and checks if (Card c) is included in the chain of co-linked cards.
---
IsFacedown(Card c) -> bool
Checks if a card is currently face-down.
---
IsFaceup(Card c) -> bool
Checks if a card is currently face-up.
---
IsFieldID(Card c, int fid) -> bool
Returns `true` if a given value is equal to a card's current location ID, a value assigned to a card whenever it changes locations.
---
IsFieldSpell(Card c) -> bool
Checks if a card is currently a [Field Spell](https://yugipedia.com/wiki/Field_Spell_Card).
---
IsFlipSummoned(Card c) -> bool
Checks if a card is currently [Flip Summoned](https://yugipedia.com/wiki/Flip_Summon).
---
IsForbidden(Card c) -> bool
Checks if a card (Card c) is forbidden to be used (equal to calling c:IsStatus(STATUS_FORBIDDEN))
---
IsFusionSummonableCard(Card c, int sumtype) -> bool
Returns if (Card c) is a card that can be fusion summoned. This checks if: -the card's type is TYPE_FUSION, -the card has an EFFECT_SPSUMMON_CONDITION applied to it. If (int sumtype) is provided, it uses that value in the step. SUMMON_TYPE_FUSION is included in sumtype by default.
---
IsFusionSummoned(Card c) -> bool
Checks if a card is currently [Fusion Summoned](https://yugipedia.com/wiki/Fusion_Summon).
---
IsGeminiState(Card c) -> bool
Use Card.IsGeminiState instead
---
IsGeminiStatus(Card c) -> bool
Checks if a Card (Card c) is a Gemini monster with its effect enabled.
---
IsGeminiSummoned(Card c) -> bool
Checks if a card is currently a [Gemini Monster that has been Normal Summoned again](https://yugipedia.com/wiki/Gemini_monster).
---
IsHasCardTarget(Card c1, Card c2) -> bool
Checks whether the second card (Card c2) is a target of the first card (Card c1)
---
IsHasEffect(Card c, int code, int player) -> Effect
Returns all the effects of a given code being applied to a card, such as by Equip and Field Effects. This also includes the card's own [Single](/api/constants/EffectType/EFFECT_TYPE_SINGLE) effects. For effects registered or being granted to a card, use [`Card.GetOwnEffects`](/api/functions/Card/GetOwnEffects).
---
IsImmuneToEffect(Card c, Effect e) -> bool
Checks if a card (Card c) is not affected by an effect (Effect e)
---
IsInExtraMZone(Card c, int tp) -> bool
Checks if (Card c) is in an Extra Monster Zone. If (int tp) is provided, also returns if (Card c) is of that controller.
---
IsInMainMZone(Card c, int tp) -> bool
Checks if (Card c) is in a Main Monster Zone. If (int tp) is provided, also returns if (Card c) is of that controller.
---
IsLeaveFieldDest(Card c, int loc) -> int
Returns `true` if a card would be sent to a given location when it leaves the field, taking into account effects that would redirect it (e.g. "but banish it if it leaves the field").
---
IsLevel(Card c, int ...) -> bool
Returns `true` if the level of a card is equal to any of the specified levels
---
IsLevelAbove(Card c, int min) -> bool
Returns `true` if the level of a card is greater than **or equal to** a specified level.
---
IsLevelBelow(Card c, int min) -> bool
Returns `true` if the level of a card is less than **or equal to** a specified level.
---
IsLevelBetween(Card c, int fst, int snd) -> bool
Returns `true` if the level of a card is between two specified levels, **inclusive**.
---
IsLink(Card c, int lk) -> bool
Checks if "c" has a Link Rating equal to "lk".
---
IsLinkAbove(Card c, int link_rating) -> bool
Checks if (Card c) has a Link Rating (link_rating) equal or greater than the given number
---
IsLinkBelow(Card c, int link_rating) -> bool
Checks if (Card c) has a Link Rating (link_rating) equal or lower than the given number
---
IsLinkCode(Card c, int ...) -> bool
Checks if "c" has a specific code from the "..." list as a Link Material.
---
IsLinked(Card c) -> bool
Checks if "c" is linked. (A card is linked if it is pointing to another card, or if another card is pointing to it.)
---
IsLinkMarker(Card c, int markers) -> bool
Checks if (Card c) has the LinkMarkers represented by (int markers)
---
IsLinkMonster(Card c) -> bool
Checks if a card is currently a [Link Monster](https://yugipedia.com/wiki/Link_Monster).
---
IsLinkSetCard(Card c, int setname) -> bool
Checks if "c" is part of the archetype "setname" as a Link Material.
---
IsLinkSpell(Card c) -> bool
Checks if a card is currently a [Link Spell](https://yugipedia.com/wiki/Link_Spell_Card).
---
IsLinkSummonable(Card c, Group|Card|nil must_use, Group|Card|nil mg, int min, int max) -> bool
Checks if "c" can be Link Summoned using "must_use" as part of its materials, choosing among "mg", with "min" and "max"as the number of materials materials to be used for the Link Summon.
---
IsLinkSummoned(Card c) -> bool
Checks if a card is currently [Link Summoned](https://yugipedia.com/wiki/Link_Summon).
---
IsLocation(Card c, int location) -> bool
Checks if a card (Card c) is located on the specified location (int location)
---
IsMaximumMode(Card c) -> bool
(To be added)
---
IsMaximumModeCenter(Card c) -> bool
(To be added)
---
IsMaximumModeLeft(Card c) -> bool
(To be added)
---
IsMaximumModeRight(Card c) -> bool
(To be added)
---
IsMaximumModeSide(Card c) -> bool
(To be added)
---
IsMonster(Card c) -> bool
Checks if a card is currently a [monster](https://yugipedia.com/wiki/Monster_Card).
---
IsMonsterCard(Card c) -> bool
Checks if a card is originally a [Monster Card](https://yugipedia.com/wiki/Monster_Card).
---
IsMSetable(any Card, bool ignore_count, Effect|nil e, int min) -> bool
Checks whether a card (Card c) can be Normal Set as a monster. Setting ignore_count to true makes it ignore the standard once per turn summon limit. If an effect (Effect e) is given, checks whether it can be Normal Summoned by that effect. The last value denotes the minimum tribute amount.
---
IsNegatable(Card c) -> bool
Checks if (Card c) can be negated (returns Card.IsNegatableMonster OR Card.IsNegatableSpellTrap)
---
IsNegatableMonster(Card c) -> bool
Checks if (Card c) can be negated (for monsters)
---
IsNegatableSpellTrap(Card c) -> bool
Checks if (Card c) can be negated (for Spell/Trap)
---
IsNonEffectMonster(Card c) -> bool
Returns `true` if the given card is currently a [Non-Effect monster](https://yugipedia.com/wiki/Non-Effect_Monster).
---
IsNormalSpell(Card c) -> bool
Checks if a card is currently a [Normal Spell](https://yugipedia.com/wiki/Normal_Spell_Card).
---
IsNormalSpellTrap(Card c) -> bool
Checks if a card is currently a Normal [Spell](https://yugipedia.com/wiki/Normal_Spell_Card)/[Trap](https://yugipedia.com/wiki/Normal_Trap_Card).
---
IsNormalSummoned(Card c) -> bool
Checks if a card is currently [Normal Summoned/Set](https://yugipedia.com/wiki/Normal_Summon).
---
IsNormalTrap(Card c) -> bool
Checks if a card is currently a [Normal Trap](https://yugipedia.com/wiki/Normal_Trap_Card).
---
IsNotMaximumModeSide(Card c) -> bool
(To be added)
---
IsNotTuner(Card c, Card scard, int player) -> bool
Returns `true` if the given card can be used for a [Synchro Summon](https://yugipedia.com/wiki/Synchro_Summon) as a [non-Tuner monster](https://yugipedia.com/wiki/Non-Tuner_monster).
---
IsOddScale(Card c) -> bool
Returns if a pendulum card (Card c) is a card with an odd value for the scale, using Card.GetScale to get the value.
---
IsOnField(Card c) -> bool
Checks if a card is currently on the field.
---
IsOriginalAttribute(Card c, int val) -> bool
Checks if (Card c) is of original attribute (int val)
---
IsOriginalCode(Card c, int cd) -> bool
Checks if (Card c) has original card name of (int cd)
---
IsOriginalCodeRule(Card c, int cd) -> bool
Checks if (Card c) has original code rule of (int cd)
---
IsOriginalLevel(Card c, int lv) -> bool
Returns `true` if a card's original level is equal to a given value.
---
IsOriginalRace(Card c, int val) -> bool
Checks if (Card c) is of original monster type (int val)
---
IsOriginalRank(Card c, int rank) -> bool
Returns `true` if a card's original rank is equal to a given value.
---
IsOriginalSetCard(Card c, int setname) -> bool
Checks if "c" is originally part of the archetype "setname".
---
IsOriginalType(Card c, int val) -> bool
Checks if (Card c) is of original CardType (int val)
---
IsOwner(Card c, int player) -> int
Returns `true` if a card is [owned](https://yugipedia.com/wiki/Owner) by a specified player.
---
IsPendulumSummoned(Card c) -> bool
Checks if a card is currently [Pendulum Summoned](https://yugipedia.com/wiki/Pendulum_Summon).
---
IsPosition(Card c, int pos) -> bool
Checks if a card (Card c) is in the specified position (int pos)
---
IsPreviousAttackOnField(Card c, int atk) -> bool
Returns `true` if a card's previous ATK on the field is equal to a given value.
---
IsPreviousAttributeOnField(Card c, int attr) -> bool
Returns `true` if a card's previous race on the field includes a given value(s).
---
IsPreviousCodeOnField(Card c, int code) -> bool
Returns `true` if a card's previous passcode on the field is equal to a given value.
---
IsPreviousControler(Card c, int tp) -> bool
Checks if (Card c) is previous controlled by player (int tp)
---
IsPreviousDefenseOnField(Card c, int def) -> bool
Returns `true` if a card's previous DEF on the field is equal to a given value.
---
IsPreviousLevelOnField(Card c, int lv) -> bool
Returns `true` if a card's previous level on the field is equal to a given value.
---
IsPreviousLocation(Card c, int location) -> bool
Checks if a card (Card c) is previously located on the specified location (int location)
---
IsPreviousPosition(Card c, int pos) -> bool
Checks if a card (Card c) is previously in the specified position (int pos)
---
IsPreviousRaceOnField(Card c, int race) -> bool
Returns `true` if a card's previous race on the field includes a given value(s).
---
IsPreviousRankOnField(Card c, int rank) -> bool
Returns `true` if a card's previous rank on the field is equal to a given value.
---
IsPreviousSequence(Card c, int seq) -> bool
Returns `true` if a card was previously in a given sequence.
---
IsPreviousSetCard(Card c, int setname) -> bool
Checks if "c" was previously part of the archetype "setname".
---
IsPreviousTypeOnField(Card c, int type) -> bool
Returns `true` if a card's previous card type on the field includes a given value(s).
---
IsProcedureSummonable(Card c, int cardtype, int sumtype, Group|Card|nil must_use, Group|Card|nil mg, int min, int max) -> bool
Checks if "c" or type "cardtype" can be Summoned according to the "sumtype" procedure using "must_use" as part of its materials, choosing among "mg", with "min" and "max" materials to be used for the Xyz Summon
---
IsPublic(Card c) -> bool
Checks if a card's (Card c) information is known to both players. In practice, about the same as c:IsPosition(POS_FACEUP)
---
IsQuickPlaySpell(Card c) -> bool
Checks if a card is currently a [Quick-Play Spell](https://yugipedia.com/wiki/Quick-Play_Spell_Card).
---
IsRace(Card c, int race, Card|nil scard, int sumtype, int playerid) -> bool
Checks if the Monster Type of "c" is "race" (if it is to be used as material for "scard" with SummonType "sumtype" by player "playerid").
---
IsRank(Card c, int ...) -> bool
Checks if "c" has a Rank equal to any of the ranks passed.
---
IsRankAbove(Card c, int rank) -> bool
Checks if a card (Card c) has rank equal or above the specified number (int rank), will return false if the card has no rank
---
IsRankBelow(Card c, int rank) -> bool
Checks if a card (Card c) has rank equal or below the specified number (int rank), will return false if the card has no rank
---
IsRealFieldID(Card c) -> int
Returns `true` if a given value is equal to a card's unique duel ID, a value assigned to a card at the start of the duel and never changes.
---
IsReason(Card c, int reason) -> bool
Checks if the reason for an event that happened to "c" is "reason" (REASON_x).
---
IsReasonCard(Card c, int rc) -> bool
Returns `true` if a given card caused the [Event](/api/enums/Event) that happened to another card.
---
IsReasonEffect(Card c, int effect) -> bool
Returns `true` if a given effect caused the [Event](/api/enums/Event) that happened to a card.
---
IsReasonPlayer(Card c, int player) -> bool
Returns `true` if a given player caused the [Event](/api/enums/Event) that happened to a card.
---
IsReincarnationSummoned(Card c) -> bool
Interacts with the functions for "Salamangreat" Reincarnation procedure. Returns if card c has CARD_SALAMANGREAT_SANCTUARY as FlagEffect
---
IsRelateToBattle(Card c) -> bool
Checks whether a card (Card c) is related to battle (either as attacker or as an attack target)
---
IsRelateToCard(Card c1, Card c2) -> bool
Checks whether a card (Card c1) is related to another card (Card c2) (That results from _c1:CreateRelation(c2)_)
---
IsRelateToChain(Card c, int chainc) -> bool
Checks whether a card (Card c) is related to the chain numbered (int chainc)
---
IsRelateToEffect(Card c, Effect e) -> bool
Checks whether a card (Card c) is related to an effect (Effect e)
---
IsReleasable(Card c, int reason) -> bool
Checks if a card (Card c) is able to be Tributed. If the reason is also provided, checks if it can be tributed for that reason, defaulting to REASON_COST.
---
IsReleasableByEffect(Card c) -> bool
Checks if a card (Card c) is able to be Tributed by a card effect
---
IsRikkaReleasable(any c) -> bool
(To be added)
---
IsRitualMonster(Card c) -> bool
Checks if a card is currently a [Ritual Monster](https://yugipedia.com/wiki/Ritual_Monster).
---
IsRitualSpell(Card c) -> bool
Checks if a card is currently a [Ritual Spell](https://yugipedia.com/wiki/Ritual_Spell).
---
IsRitualSummoned(Card c) -> bool
Checks if a card is currently [Ritual Summoned](https://yugipedia.com/wiki/Ritual_Summon).
---
IsScale(Card c, int sc) -> bool
Returns `true` if a card's Pendulum Scale is equal to a given value.
---
IsSequence(any c, any ...) -> bool
Returns if a Card (Card c) is located at any of the sequences passed as arguments
---
IsSetCard(Card c, int|table setname, Card|nil scard, int sumtype, int playerid) -> bool
Checks if "c" is part of the archetype "setname" (if it is to be used as material for "scard" with SummonType "sumtype" by player "playerid"). "setname" can be a single int value or a table with multiple archetypes.
---
IsSpecialSummonable(Card c) -> bool
Checks if a card (Card c) is summonable by it's summon procedure
---
IsSpecialSummoned(Card c) -> bool
Checks if a card is currently [Special Summoned](https://yugipedia.com/wiki/Special_Summon).
---
IsSpell(Card c) -> bool
Checks if a card is currently a [Spell](https://yugipedia.com/wiki/Spell_Card).
---
IsSpellCard(Card c) -> bool
Checks if a card is originally a [Spell Card](https://yugipedia.com/wiki/Spell_Card).
---
IsSpellTrap(Card c) -> bool
Checks if a card is currently a [Spell](https://yugipedia.com/wiki/Spell_Card)/[Trap](https://yugipedia.com/wiki/Trap_Card).
---
IsSpellTrapCard(Card c) -> bool
Checks if a card is originally a [Spell](https://yugipedia.com/wiki/Spell_Card)/[Trap](https://yugipedia.com/wiki/Trap_Card) Card.
---
IsSSetable(Card c, bool ignore_field) -> bool
Checks whether a card (Card c) can be Set in S/T zone. Setting ignore_field to true makes it not check for free space in the S/T Zone.
---
IsStatus(Card c, int status) -> bool
Checks if "c" has the given status (STATUS_x)
---
IsSummonable(Card c, bool ignore_count, Effect|nil e, int min) -> bool
Checks whether a card (Card c) can be Normal Summoned. Setting ignore_count to true makes it ignore the standard once per turn summon limit. If an effect (Effect e) is given, checks whether it can be Normal Summoned by that effect. The last value denotes the minimum tribute amount.
---
IsSummonableCard(Card c) -> bool
Checks if a card (Card c) is normally summonable, returns false when the card is subject of Card.EnableUnsummonable or Card.EnableReviveLimit
---
IsSummonCode(Card c, Card|nil sc, int sumtype, int playerid, int ...) -> bool
Checks if "c" has a specific code from the "..." list if it is to be used as material for the SummonType "sumtype" of "sc" performed by the player "playerid".
---
IsSummonLocation(Card c, int loc) -> bool
Checks if (Card c) was summoned from the location passed as (int loca)
---
IsSummonPlayer(Card c, int tp) -> bool
Checks if (Card c) is summoned by player (int tp)
---
IsSummonType(Card c, int ...) -> bool
Checks if "c" is Summoned by one of the SummonTypes in the "..." list.
---
IsSynchroSummonable(Card c, Group|Card|nil must_use, Group|Card|nil mg, int min, int max) -> bool
Checks if "c" can be Synchro Summoned using "must_use" as part of its materials, choosing among "mg", with "min" and "max" materials to be used for the Synchro Summon. How this works is that the script would check for all EFFECT_SPSUMMON_PROC that has SUMMON_TYPE_SYNCHRO as it's Value, then checks the effects' Condition with the provided arguments. Check out "aux.SynCondition" in "proc_synchro.lua" for how this is handled.
---
IsSynchroSummoned(Card c) -> bool
Checks if a card is currently [Synchro Summoned](https://yugipedia.com/wiki/Synchro_Summon).
---
IsTextAttack(Card c, int atk) -> bool
Returns `true` if a card's printed ATK is equal to a given value. Printed ATK might differ from the original ATK of the card due to effects that change original ATK. Use [`Card.IsBaseAttack`](/api/functions/Card/IsBaseAttack) if you need to check for the original ATK instead.
---
IsTextDefense(Card c, int def) -> bool
Returns `true` if a card's printed DEF is equal to a given value. Printed DEF might differ from the original DEF of the card due to effects that change original DEF. Use [`Card.IsBaseDefense`](/api/functions/Card/IsBaseDefense) if you need to check for the original DEF instead.
---
IsTrap(Card c) -> bool
Checks if a card is currently a [Trap](https://yugipedia.com/wiki/Trap_Card).
---
IsTrapCard(Card c) -> bool
Checks if a card is originally a [Trap Card](https://yugipedia.com/wiki/Trap_Card).
---
IsTrapMonster(Card c) -> bool
Returns `true` if the given card is a [Trap Monster](https://yugipedia.com/wiki/Trap_Monster). This function does not actually check for the [`TYPE_TRAPMONSTER`](/api/constants/CardType/TYPE_TRAPMONSTER) card type, and instead checks if it's a Trap Card with an original Level, Race, or Attribute.
---
IsTributeSummoned(Card c) -> bool
Checks if a card is currently [Tribute Summoned/Set](https://yugipedia.com/wiki/Tribute_Summon).
---
IsType(Card c, int type) -> bool
Returns `true` if a card currently has *any* of the given type(s).
---
IsXyzLevel(Card c, Card xyzc, int lv) -> bool
Checks if "c" would be Level "lv" if it was to be used as Xyz Material for "xyzc".
---
IsXyzSummonable(Card c, Group|Card|nil must_use, Group|Card|nil mg, int min, int max) -> bool
Checks if "c" can be Xyz Summoned using "must_use" as part of its materials, choosing among "mg", with "min" and "max" materials to be used for the Xyz Summon
---
IsXyzSummoned(Card c) -> bool
Checks if a card is currently [Xyz Summoned](https://yugipedia.com/wiki/Xyz_Summon).
---
Level(Card c) -> int
Returns a card's original level, rank, or link-rating.
---
LinkMarker(Card c) -> int
Returns the card's original link marker(s).
---
ListsArchetype(Card c, int ...) -> bool
Returns if (Card c) lists any of the setcodes passed in (int ...), by iterating over Card c's listed_series.
---
ListsArchetypeAsMaterial(Card c, int ...) -> bool
Checks if 1 of the setcodes in (int ...) is a listed archetype in a material of (Card c)
---
ListsCardType(Card c, int ...) -> bool
Returns true if (Card c) specifically lists any of the CardTypes passed in (int ..), (which means that it iterates over Card c's listed_card_types)
---
ListsCode(Card c, int ...) -> bool
Checks if 1 of the codes in (int ...) is a listed card in (Card c)'s text
---
ListsCodeAsMaterial(Card c, int ...) -> bool
Checks if 1 of the codes in (int ...) is a listed Fusion Material in (Card c)
---
ListsCodeWithArchetype(Card c, int ...) -> bool
Returns if the (Card c) specifically lists the name of a Card that is part of an archetype in "...", iterating over Card c's listed_names and checking if those cards belong to any of the archetypes passed.
---
ListsCounter(Card c, int counter_type) -> bool
Checks if (Card c) has an effect that mentions (int counter_type) counter. This includes adding, removing, gaining ATK/DEF per counter, etc. Corresponding table: "s.counter_list" ("s.counter_place_list" is already handled)
---
Lscale(Card c) -> int
Returns a card's left Pendulum Scale.
---
MoveAdjacent(Card c, int sel_player) -> 
Executes a move operation for card c, to one of its available adjacent sequences (int the Monster Zone)
---
NegateEffects(Card tc, Card rc, int resets, bool negates_cards, int ct) -> 
Function to shorten effects that negate other cards' effects (via an activated effect). (Card tc) is the card to be negated, (Card rc) is the reason card (the one registering the effect), (int resets) are the  flags used to reset the effect (RESET_EVENT|RESETS_STANDARD are inherently included). If (bool negates_cards) is true, trap monsters are also negated and (int ct) is the counter for when phase-specific resets are required. This function also calls Duel.NegateRelatedChain.
---
PlacesCounter(Card c, int counter_type) -> bool
Checks whether card c has an effect that places int counter_type counters (on itself or others). Corresponding table: "s.counter_place_list".
---
Race(Card c) -> int
Returns the card's original race(s).
---
Recreate(Card c, int code, int|nil alias, int|nil setcode, int|nil type, int|nil level, int|nil attribute, int|nil race, int|nil atk, int|nil def, int|nil lscale, int|nil rscale, bool|nil replace_effect) -> 
Changes (Card c) into a card with (int code) as its original card number from the database. If any of the parameters are included, that stat is also changed. If (bool replace_effect) is set to true, its effect also changes to the effects of (int code).
---
RegisterEffect(Card c, Effect e, bool forced, any ...) -> int
Registers an Effect (Effect e) (usually an Effect created with Effect.CreateEffect()) to a Card (Card c), ... is a list of integers which Registers further effects in the utility.
---
RegisterEffectRush(Card c) -> int
(To be added)
---
RegisterFlagEffect(Card c, int code, int reset_flag, int property, int reset_count, int label, int desc) -> Effect
Registers a flag effect to a card (Card c) with (int code) that resets with (int reset_flag), as the EffectCode. (int reset_flag).
---
ReleaseEffectRelation(Card c, Effect e) -> 
Releases any relation between a card (Card c) and an effect (Effect e)
---
ReleaseRelation(Card c1, Card c2) -> 
Releases the relation between the first card (Card c1) and the second card (Card c2). Does not release relation from the second card that is resulting from _c2:CreateRelation(c1)_
---
RemoveAllCounters(Card c) -> 
(To be added)
---
RemoveCounter(Card c, int player, int countertype, int count, int reason) -> 
Removes a number (int count) of the specified counter (int countertype) from a card (Card c), with reason described by (int reason)
---
RemoveOverlayCard(Card c, int player, int min, int max, int reason) -> int
Makes player (int Player) remove overlay cards from a Card (Card c), with minimum of (int min) and maximum of (int max) with (int reason) as reason. Returns the number of cards removed
---
ReplaceEffect(Card c, int code, int reset_flag, int reset_count) -> int
Temporarily replace all effects of a card (Card c) with the effect of card with the specified card code (int code) that resets according to the ascribed reset flag (int reset_flag)
---
ResetEffect(Card c, int reset_code, int reset_type) -> 
Resets all effects of a Card (Card c) (e.g. "c:ResetEffect(RESET_DISABLE,RESET_EVENT)")
---
ResetFlagEffect(Card c, int code) -> 
Resets a flag with (int code) as the EffectCode from a card (Card c)
---
ResetNegateEffect(Card c, int code1, any ...) -> 
Resets a card c affected by the effect of cards whose card number is code1, code2 ...
---
ReverseInDeck(Card c) -> 
Reverses a card (Card c) in Deck (make it face-up)
---
Rscale(Card c) -> int
Returns a card's right Pendulum Scale.
---
SelectAdjacent(Card c, int sel_player) -> number
Makes (int player) select a zone adjacent (horizontally) to (card c)
---
SetCardTarget(Card c1, Card c2) -> 
Sets the second card (Card c2) as a target of the first card (Card c1)
---
Setcode(Card c) -> int
Returns the card's original archetype(s).
---
SetCounterLimit(Card c, int countertype, int count) -> 
Sets the limit (int count) of how many counter of a type (int countertype) can be held by a card (Card c)
---
SetFlagEffectLabel(Card c, int code, int label) -> bool
Assigns an integer (int label) number to the flag effect attached to a card (Card c) with (int code) as the EffectCode. Returns true if a flag effect with such code existed and the label was set.
---
SetHint(Card c, int type, int value) -> 
Sets a card (Card c) hint displaying, type is CHINT_* and value is the appropriate value depending on the type
---
SetMaterial(Card c, Card|Group|nil materials) -> 
Sets the Material of a Card (Card c) to the passed ones. If nil is passed, the material group of the card is cleared.
---
SetReason(Card c, int reason, bool keep) -> 
Sets the reason of "c" as "reason". If "keep" is set to true "c" will maintain the previous reason that it had.
---
SetReasonCard(Card c, Card rc) -> 
Sets "rc" as the card that was the reason of an event that happened to "c".
---
SetReasonEffect(Card c, Effect re) -> 
Sets "re" as the effect that was the reason of an event that happened to "c".
---
SetReasonPlayer(Card c, int rp) -> 
Sets "rp" as the player that was the reason of an event that happened to "c".
---
SetSPSummonOnce(Card c, int spsummon_code) -> 
Makes so (Card c) can only be Special Summoned when the turn has not Special Summoned another card with the same code (int code) as its Card.SetSpecialSummonOnce. In other words: creates the "You can only Special Summon "Some Monster" once per turn" condition.
---
SetStatus(Card c, int status, bool enable) -> 
Sets the status (STATUS_x) of a Card (Card c) and possibly enables it
---
SetTurnCounter(Card c, int counter) -> 
Sets the turn counter of a Card (Card c) to a value (int count)
---
SetUniqueOnField(Card c, int s, int o, int unique_code, int unique_location) -> 
Sets a card's (Card c) "Can only control 1" clause, int s denotes checking of the would-be owner's field, int o denotes checking the opposing field. unique_location denotes the location the card is unique (setting location outside the field has no meaning)
---
Type(Card c) -> int
Returns a card's original type(s).
---
UpdateAttack(Card c, int amount, int reset, Card rc) -> int
Applies an ATK change to card c, equal to int amount. If the reset values (int reset) are not provided, the default is RESET_EVENT (+RESETS_STANDARD_DISABLE , if rc == c, or just +RESETS_STANDARD). If the reason card rc is not provided, uses as default card c. Returns the amount of ATK successfully changed.
---
UpdateDefense(Card c, int amount, int reset, Card rc) -> int
Applies a DEF change to card c, equal to int amount. If the reset values (int reset) are not provided, the default is RESET_EVENT (+RESETS_STANDARD_DISABLE , if rc == c, or just +RESETS_STANDARD). If the reason card rc is not provided, uses as default card c. Returns the amount of DEF successfully changed.
---
UpdateLevel(Card c, int amount, int reset, Card rc) -> int
Applies a level change to card c, equal to int amount. If the reset values (int reset) are not provided, the default is RESET_EVENT (+RESETS_STANDARD_DISABLE if rc == c, or just +RESETS_STANDARD) If the reason card rc is not provided, uses as default card c. Returns the amount of levels successfully changed.
---
UpdateLink(Card c, int amount, int reset, Card rc) -> int
Applies a link change to card c, equal to int amount. If the reset values (int reset) are not provided, the default is RESET_EVENT (+RESETS_STANDARD_DISABLE if rc == c, or just +RESETS_STANDARD). If the reason card (card rc) is not provided, uses as default card c. Returns the amount of links successfully changed.
---
UpdateRank(Card c, int amount, int reset, Card rc) -> int
Applies a rank change to card c, equal to int amt.If the reset values (int reset) are not provided, the default is RESET_EVENT (+RESETS_STANDARD_DISABLE if rc == c, or just +RESETS_STANDARD). If the reason card rc is not provided, uses as default card c. Returns the amount of ranks successfully changed.
---
UpdateScale(Card c, int amount, int reset, Card rc) -> int
Applies a scale change to card c, equal to int amount. If the reset values (int reset) are not provided, the default is RESET_EVENT (+RESETS_STANDARD_DISABLE if rc == c, or just +RESETS_STANDARD). If the reason card rc is not provided, uses as default card c. Returns the amount of scales successfully changed.
---
WasMaximumMode(Card c) -> bool
(To be added)
---
WasMaximumModeSide(Card c) -> bool
(To be added)
---
Debug.AddCard(int code, int owner, int player, int location, int seq, int pos, bool sum_proper) -> Card
Creates a new `Card` with the specified ID and places it in the location provided.
---
Debug.Message(string|number|Card message) -> 
Sends a message as a script error to the logs.
---
Debug.PreAddCounter(Card c, int counter_type, int count) -> 
Adds a certain number of a specified counter to a card.
---
Debug.PreEquip(Card equip_card, Card target) -> bool
In puzzles, equips one card to another. Will fail if the equip card is not in a Spell/Trap Zone, or if the equip target is not in a Monster Zone face-up.
---
Debug.PreSetTarget(Card c, Card tc) -> 
In puzzles, sets the target of a card to be a specified card. Useful when placing cards on the field that require a target to keep the effect relation (e.g., [Call of the Haunted](https://yugipedia.com/wiki/Call_of_the_Haunted)).
---
Debug.PreSummon(Card c, int sum_type, int sum_location, int sum_sequence, bool sum_pzone) -> 
In puzzles, treats a card as if it was summoned by the provided [SummonType](/api/enums/SummonType). The summon location and sequence can also be specified.
---
Debug.ReloadFieldBegin(int flag, int rule, bool ignore_rule) -> 
Begins loading the field for a puzzle, with DUEL_ constants in (int flag) under Master Rule (int rule). If (bool ignore_rule) is set to true, then the master rules from (int flag) are ignored and the field is constructed only from the duel flags provided
---
Debug.ReloadFieldEnd() -> 
Stops loading the field for a puzzle.
---
Debug.SetAIName(string name) -> 
In puzzles, sets the name of the second player to a specified string.
---
Debug.SetPlayerInfo(int playerid, int lp, int startcount, int drawcount) -> 
In puzzles, sets a player's LP, initial number of cards in the hand, and the number of cards to draw each Draw Phase.
---
Debug.ShowHint(string message) -> 
In puzzles, displays a message on the screen.
---
Duel.Activate(Effect e) -> 
Activates an effect in a new chain link. If the effect is the activate effect of a spell/trap, that card is also activated.
---
Duel.ActivateFieldSpell(Card c, any e, any tp, any eg, any ep, any ev, any re, any r, any rp, any target_p) -> bool
Activates a field spell Card "c". Already handles interactions with Field Spells that are already face up, rules for only 1 Field Spell at time, checks for costs and activated effects of the field spell and als the interaction with Ancient Pixie Dragon.
---
Duel.AddCustomActivityCounter(int counter_id, int activity_type, function f) -> 
Registers an activity with type (int activity_type), with id (int counter_id), that matches (function f)
---
Duel.AddNoTributeCheck() -> 
(To be added)
---
Duel.AdjustInstantly(Card c) -> 
Adjusts the game state checking self destroy effects, continuous negation effects being applied, etc. If a card is passed, it also adjust immediately the properties of that card and cards related to it.
---
Duel.AnnounceAnotherAttribute(Group g, int player) -> int
Makes (int player) announce an attribute different from the one(s) already among the members of (group g)
---
Duel.AnnounceAnotherRace(Group g, int player) -> int
Makes (int player) announce a monster type (Race) different from the one(s) already among the members of (Group g)
---
Duel.AnnounceAttribute(int player, int count, int available) -> int
Asks (int player) to announce (int count) number of Attributes, amongst those specified in (int available).
---
Duel.AnnounceCard(int player, any ...) -> int
Makes the player declare a card name. With no extra parameters, the function allows declaring any monster, spell and trap card names. If a single int parameter is passed as second parameter, that parameter will be used to limit the types that are declarable (for example passing TYPE_MONSTER to only declare monster cards). If 3 or more parameters are passed, the function will use the OPCODE_ constants to build a filter based on the reverse polish notation to allow declaring cards with more specific restrictions (for example declaring cards of a specific archetype only). The opcode parameters can also be passed all in a table as the second parameter.
---
Duel.AnnounceCoin(int player, bool confirm_dialog) -> int
Asks (int player) to call heads or tails. Returns COIN_HEADS or COIN_TAILS. If confirm_dialog is false, the announce will be performed, but the no selection hint will be shown to the opponent
---
Duel.AnnounceLevel(int player, int min, int max, int exception, any ...) -> int|nil
Asks (int player) to announce a number between (int min) and (int max), except any (int exception)s. Returns the chosen number, and the index of that number amongst the choices.
---
Duel.AnnounceNumber(int player, int number, any ...) -> int
Asks (int player) to announce a number found amongst (int number)s. Returns the chosen number and its index amongst the options
---
Duel.AnnounceNumberRange(int player, int min, int max, any ...) -> int|nil
Asks (int player) to announce a number between (int min) and (int max). Extra integers can be  passed as the exceptions. Returns the chosen number, and the index of that number amongst the choices.
---
Duel.AnnounceRace(int player, int count, int available) -> int
Asks (int player) to announce (int count) number of Races, amongst those specified in (int available).
---
Duel.AnnounceType(int player) -> int
Makes (int player) declare a type
---
Duel.AskAny(any stringid) -> int
(To be added)
---
Duel.AskEveryone(any stringid) -> int
(To be added)
---
Duel.AssumeReset() -> 
Manually resets assumed effects. Usually used in Synchro Summon procedure (eg: it resets the applied effect of "Influence Dragon (Anime)" on the other materials in the Synchro Summon.)
---
Duel.AttackCostPaid(int paid) -> 
Registers the status of payment of attack cost. A value of 2 means that the attack cost was not paid, 1 means the attack cost was paid.
---
Duel.BreakEffect() -> 
Separates an effect for the purposes of timing (Reflects the effects of the conjunctives "then" and "also after that")
---
Duel.CalculateDamage(Card c1, Card|nil c2) -> 
Conduct damage calculation between (Card c1) as attacker and (Card c2) or opponent player (nil)
---
Duel.CallCoin(int player) -> bool
Tosses a coin and returns true if the player guessed right, false if he didn't
---
Duel.CanPlayerSetMonster(int player, Card sumcard, int sumtype) -> bool
Returns if player can set a monster, if sumcard and sumtype are passed, those parameters are also passed to the EFFECT_CANNOT_MSET effects.
---
Duel.CanPlayerSetSpellTrap(int player, Card setcard) -> bool
Returns if player can set a spell/trap card, if setcard is passed, that parameter is also passed to the EFFECT_CANNOT_SSET effects.
---
Duel.ChainAttack(Card c) -> 
Makes the currently attacking card attacks able to declare a consecutive attack after the current one. If a card is passed, the next attack will have to be against that specific card.
---
Duel.ChangeAttacker(Card c, int ign) -> 
Changes the current monster attacking to another card (Card c), if ignore counts is set to true (int ign) it will ignore if the card can still attack.
---
Duel.ChangeAttackTarget(Card|nil c) -> bool
Changes the current monster being attacker to another card (or makes the attack a direct attack in case of no card being passed)
---
Duel.ChangeBattleDamage(int player, int value, bool check) -> 
Changes the battle damage (int player) would take to (int value). If (bool check) == false, you are able change the battle damage that originally is 0.
---
Duel.ChangeChainOperation(int chain_idx, function f) -> 
Replaces the operation executed by the effect at the specific chain index with the passed function.
---
Duel.ChangePosition(Card|Group targets, int au, int ad, int du, int dd, bool noflip) -> int
Changes the battle position of (Card|Group targets). (int au), (int ad), int (du) and (int dd) are the positions cards in face-up attack, face-down attack, face-up defense, and face-down defense positions will be changed to, respectively. If (bool noflip) is true, FLIP effects will not be activated by this change. Returns the number of cards successfully affected.
---
Duel.ChangeTargetCard(int chainc, Group g) -> 
Changes the target cards for the specific chain link (0 is the currently resolving one). This alters the value that that chain link set with Duel.SetTargetCards
---
Duel.ChangeTargetParam(int chainc, int param) -> 
Changes the target parameter for the specific chain link (0 is the currently resolving one). This alters the value that that chain link set with Duel.SetTargetParam
---
Duel.ChangeTargetPlayer(int chainc, int player) -> 
Changes the target player for the specific chain link (0 is the currently resolving one). This alters the value that that chain link set with Duel.SetTargetPlayer
---
Duel.CheckChainTarget(int chainc, Card c) -> bool
Checks if a card (Card c) can be a target for a chain's (int chainc) effect (via calling target(chkc) function of the effect)
---
Duel.CheckChainUniqueness() -> bool
Checks if there is no card with the same name in the current chain
---
Duel.CheckEvent(int event, bool get_info) -> bool
Returns if, at the activation timing, the (int event) passed is available. If (bool get_info) is set to true, all the even info are returned as extra return values
---
Duel.CheckLocation(int player, int location, int seq) -> bool
Checks if there is an position (int seq) available for the player (int player) in the location (int location). (The sequence (int seq) is used to indicate the specific position of the location, for example in the location of monsters the sequence would go from 0 to 7., etc.)
---
Duel.CheckLPCost(int player, int cost) -> bool
Checks if a player (int player) can pay an amount (int cost) of LP
---
Duel.CheckPendulumZones(int player) -> bool
Returns if (int player) has at least one Pendulum zone free, using Duel.CheckLocation.
---
Duel.CheckPhaseActivity() -> bool
Checks if the an "activity" was not performed yet which means that the player is at "the start" of the current phase. Used for effects like Pot of Extravagance, Soundproofed and Mimir of the Nordic Ascendant.
---
Duel.CheckReleaseGroup(int player, function f, int count, bool use_hand, int max, bool check_field, Card card_to_check, int to_player, int zone, bool use_oppo, Group|Card|nil ex, any ...) -> bool
Checks if there is a monster that can be used as tribute from the int player, that satisfies function, having a min and a max of the count specified with the exception of some card/group if specified, ... are extra arguments. If use_hand is true, then cards in the hand are considered for the tribute. If use_oppo is true, opponent's cards are also considered for the tribute. If check_field is true and card_to_check is passed, the function will also take in account to check if there are free zones (int zone) left on to_player's field to summon that card after tributing the cards. Also effects of cards like "Lair of Darkness" are taken into account when performing those checks.
---
Duel.CheckReleaseGroupCost(int player, function f, int minc, int maxc, bool use_hand, function spcheck, Card|Group|nil ex, any ...) -> bool
Checks if the player can tribute cards on the field, excluding "ex" to activate the effect of a monster while also checking for applied effects of cards like "Lair of Darkness" (behaviour now also implemented in the normal CheckReleaseGroup). If function f is passed, the cards returned by Duel.GetReleaseGroup are filtered based on that function. The function spcheck is a callback function that gets passed the current checked group (sg) as first parameter, the checking player (tp) as second parameter, a group containing opponent's cards affected by EFFECT_EXTRA_RELEASE_NONSUM or EFFECT_EXTRA_RELEASE (exg) and the extra parameters passed to the function (...). The spcheck function has to return 1 or 2 boolean values indicating if the passed group (sg) satisfy the requirements as first return value and as optional second parameter to indicate if no matter how many new cards are added to (sg), the condition will never return true.
---
Duel.CheckReleaseGroupEx(int player, function f, int count, bool use_hand, int max, bool check_field, Card card_to_check, int to_player, int zone, bool use_oppo, Group|Card|nil ex, any ...) -> bool
Same as Duel.CheckReleaseGroup, except that the hand is included by default.
---
Duel.CheckReleaseGroupSummon(Card c, int player, Effect e, function fil, int min, int max, function last, any ...) -> bool
(To be added)
---
Duel.CheckRemoveOverlayCard(int player, int s, int o, int count, int reason, Group ocard) -> bool
Returns if (int player) can remove a total of (int count) cards attached, for reason (int reason) from your field (int s == 1) and/or opponent's (int o == 1). If group (ocard) is provided, only checks if cards can be detached from monsters that match said group.
---
Duel.CheckSummonedCount(Card c) -> bool
Checks if the current reason player can still normal summon other monsters or has used that turn's summons, or if a card is passed and that card is affected by an EFFECT_EXTRA_SUMMON_COUNT effect allowing it to be summoned.
---
Duel.CheckTiming(int timing) -> bool
Returns true if the current activation hint timing is one of the passed timings.
---
Duel.CheckTribute(Card c, int min, int max, Group|nil mg, int tp) -> bool
Checkd if there are valid tributes on the field to summon Card c to tp's field in the zones specified by zone using the rules of a normal tribute summon.
---
Duel.ClearOperationInfo(int chainc) -> 
Clears all the informations that were set by Duel.SetOperationInfo for the passed chain.
---
Duel.ClearTargetCard() -> 
Removes all the targeted cards corresponding to the current resolving/building chain.
---
Duel.ConfirmCards(int player, Card|Group targets) -> 
Reveals the passed cards to the passed player if they are in a private knowledge state.
---
Duel.ConfirmDecktop(int player, int count) -> 
Reveals a number (int count) of cards from the top of a player's (int player) Deck to both players
---
Duel.ConfirmExtratop(int tp, int count) -> 
Reveals a number (int count) of  facedown cards from the top of a player's (int player) Extra Deck to both players. (faceup pendulum monsters are ignored)
---
Duel.CountHeads(any results, any ...) -> int
(To be added)
---
Duel.CountTails(any results, any ...) -> int
(To be added)
---
Duel.CreateToken(int player, int code) -> Card
Creates a new instance of a card owned by player (int player) with card code (int code).
---
Duel.Damage(int player, int value, int reason, bool is_step, int rp) -> int
Damages/Decreases player's (int player) Life Points by an amount (int value) for a reason (int reason). The damage is considered to be dealt by (int rp). Setting (bool is_step) to true will make so the damage is considered dealt at the call of Duel.RDComplete().
---
Duel.Destroy(Card|Group targets, int reason, int dest, int rp) -> int
Destroys a card or group (Card|Group targets) with (int reason) as reason, and sends the card in the location specified by (int dest). If (int rp) is passed, sets the reason player to be that player. Returns the number of cards successfully destroyed.
---
Duel.DisableSelfDestroyCheck(any disable) -> 
If disable is true, prevents the core from performing the checks for cards that self destroy themselves (like "Burning Abyss" monsters). This behaviour persists until it's manually enabled again by passing false.
---
Duel.DisableShuffleCheck(any disable) -> 
If disable is true, makes an action that adds/removes a card(s) from/to Deck/hand not trigger the shuffle check at the end of the the current routine execution. Putting false would revert to normal behavior.
---
Duel.DiscardDeck(int player, int count, int reason) -> int
Makes player (int player) send a number of cards (int count)  from the top of their Deck  to the Graveyard (discard mechanic) with the reason defined by (int reason)
---
Duel.DiscardHand(int player, function|nil f, int min, int max, int reason, Group|Card|nil ex, any ...) -> int
Makes (int player) discard between (int min) and (int max) cards from their hand for which (function f) returns true  sing as reason (int reason), except  (Group|Card ex).
---
Duel.Draw(int player, int count, int reason) -> int
Player (int player) draws a specific amount (int count) of Cards for a reason (REASON_x)
---
Duel.EnableGlobalFlag(int global_flag) -> 
Enables the specified GlobalFlags (int global_flag) for the rest of the Duel (GLOBALFLAG_x).
---
Duel.Equip(int player, Card c1, Card c2, bool up, bool is_step) -> bool
A Player (int player) equips a Card (Card c1) to another Card (Card c2). When up is false, the equip card will not have its position changed face-up. is_step is for using with Duel.EquipComplete. Returns true if the equip is successful.
---
Duel.EquipComplete() -> 
Concludes a series of Equips (Always used with 'is_step = true' in Duel.Equip())
---
Duel.ForceAttack(Card c1, Card c2) -> 
Last Turn's specific effect: after the chain resolves, switches to a standalone Battle Phase and makes card (card c1) attack (card c2). After that, returns to the previous phase.
---
Duel.GetActivityCount(int player, int activity_type, any ...) -> int
Gets the number of times (int player) has performed activities of (int activity_type). (See ACTIVITY_XXX constants,)
---
Duel.GetAttacker() -> Card
Gets the attacking card (or nil if there is no attacker)
---
Duel.GetAttackTarget() -> Card|nil
Gets the attack target card (or nil if there's no attack target/the attack is a direct attack)
---
Duel.GetBattleDamage(int player) -> int
Gets the battle damage (int player) would take
---
Duel.GetBattledCount(int player) -> int
Gets the number of battles (int player) has been involved in this turn
---
Duel.GetBattleMonster(int tp) -> Card|nil
Returns as first value the monster that is currently battling from the perspective of tp (nil if tp has no currently battling monsters), as second value returns the battling monster from the perspective of 1-tp.
---
Duel.GetCardAliasFromCode(int id) -> int
Retrieves the alias of a given card passcode/ID from the card database.
---
Duel.GetCardAttackFromCode(int id) -> int
Retrieves the ATK of a given card passcode/ID from the card database.
---
Duel.GetCardAttributeFromCode(int id) -> int
Retrieves the attribute(s) of a given card passcode/ID from the card database.
---
Duel.GetCardDefenseFromCode(int id) -> int
Retrieves the DEF of a given card passcode/ID from the card database.
---
Duel.GetCardFromCardID(int cardid) -> Card
Returns the card whose internal id matches cardid, if no card matches, nil is returned.
---
Duel.GetCardLevelFromCode(int id) -> int
Retrieves the level of a given card passcode/ID from the card database.
---
Duel.GetCardLinkMarkerFromCode(int id) -> int
Retrieves the link marker(s) of a given card passcode/ID from the card database.
---
Duel.GetCardLscaleFromCode(int id) -> int
Retrieves the left pendulum scale of a given card passcode/ID from the card database.
---
Duel.GetCardRaceFromCode(int id) -> int
Retrieves the race(s) of a given card passcode/ID from the card database.
---
Duel.GetCardRscaleFromCode(int id) -> int
Retrieves the right pendulum scale of a given card passcode/ID from the card database.
---
Duel.GetCardSetcodeFromCode(int code) -> int
Gets a card's setcodes from its card id (the value returned is the same as the one returned with Card.Setcode on a card object corresponding to a card with such id)
---
Duel.GetCardTypeFromCode(int id) -> int
Retrieves the card type(s) of a given card passcode/ID from the card database.
---
Duel.GetChainEvent(int chain) -> Group|nil
Returns the elements associated with the event that caused the current chain link to form, in order: The group containing the cards that were associated with that event, The player associated with that event, The value associated with that event, The reason Effect associated with that event, The reason associated with that event, The reason player associated with that event.
---
Duel.GetChainInfo(int chainc, any ...) -> any
Returns the chain link properties (aka, ChainInfo, described by constant group CHAININFO_) of the passed chain link (int chainc), or current chain if it's 0.
---
Duel.GetChainMaterial(int player) -> Effect
Gets the EFFECT_CHAIN_MATERIAL field effect that is applied to a player (int player). Returns only the first effect found
---
Duel.GetCoinResult() -> any
Returns the values corresponding to the results of the last coins tosses.
---
Duel.GetControl(Card|Group targets, int player, int reset_phase, int reset_count, int zone, int chose_player) -> bool
Gives control of a card/group (Card|Group targets) to a player (int player). If reset_phase and reset_count is specified, will behave like other effects with those resets (and so, the control will be returned when the effect has expired). Works only for monsters in Monster Zone, if zone is specified, if moves monster to that zones only or destroy if they are full. If chose_player is provided, the player selecting the zone is the passed value, if PLAYER_NONE is passed, the player performing the selection is player (int player), otherwise the selecting player will be the current reason player.
---
Duel.GetCounter(int player, int s, int o, int countertype) -> int
Gets the number of counter (int countertype) on the field, from a player's (int player) perspective. The variables int s and int o are the player's and the opponent's field, respectively, 0 to exclude and 1 (or higher) to include.
---
Duel.GetCurrentChain(bool real_chain) -> int
Returns the number of the current chain link. If real chain is true, then it will return the number of ACTUAL chains that have already formed, so in a target or cost function, it will not include the current chain in this count, while with that parameter as false the current chain will be included as well. Set this when you need to check for the current chain in an effect condition.
---
Duel.GetCurrentPhase() -> int
Gets the current Phase of the game (corresponds to PHASE_x in constants.lua)
---
Duel.GetCustomActivityCount(int counter_id, int player, int activity_type) -> int
Same behaviour as Duel.GetActivityCount with the difference that returns the count of the activities that were registered with the specific counter_id as Duel.AddCustomActivityCounter.
---
Duel.GetDeckbottomGroup(int player, int count) -> Group
Returns a group with the (int count) cards on the bottom of (int player)'s Deck
---
Duel.GetDecktopGroup(int player, int count) -> Group
Gets a group of a player's (int player) top n (int count) cards of their Deck
---
Duel.GetDiceResult() -> any
Returns the values corresponding to the results of the last dice rolls.
---
Duel.GetDrawCount(int player) -> int
Gets the draw count for normal draw for a player (int player)
---
Duel.GetDuelType() -> int
Returns all of the Duel flags used in the current duel
---
Duel.GetEnvironment() -> int
Gets the environment code for the applied field card (the same as the Field Spell's code, usually). Returns the code, then the controlling player. Prioritizes the first player. **deprecated and should be avoided**
---
Duel.GetExtraTopGroup(int player, int count) -> Group
Gets a group of a player's (int player) top n (int count) facedown cards of their Extra Deck
---
Duel.GetFieldCard(int player, int location, int seq) -> Card
Gets a card in certain location at a certain sequence
---
Duel.GetFieldGroup(int player, int s, int o) -> Group
Gets a group containing cards from a specified location of a player (int player), s denotes the player's side of the field, o denotes opposing player's side of the field
---
Duel.GetFieldGroupCount(int player, int s, int o) -> int
Counts the number of cards from a specified location of a player (int player), s denotes the player's side of the field, o denotes opposing player's side of the field
---
Duel.GetFieldGroupCountRush(int player, int s, int o) -> int
Same as Duel.GetFieldGroupCount but exclude the left and right pieces of a summoned maximum monster
---
Duel.GetFirstMatchingCard(function f, int player, int s, int o, Group|Card|nil ex, any ...) -> Card
Get the first card in locations (int s) (on (int player)'s side of the field) and (int o) (on their opponent's) for which (function f) returns true, except (Card ex)
---
Duel.GetFirstTarget() -> Card
Returns all the cards that got targeted in the current chain link as separate return values, Duel.GetChainInfo(0,CHAININFO_TARGET_CARDS) is an equivalent alternative that directly returns a group. Duel.GetTargetCards() is a better alternative that returns a group and of target cards that are filtered depending on their relation to the effect.
---
Duel.GetFlagEffect(int player, int code) -> int
Gets the flag effect with (int code) as the EffectCode that is registered to a player (int player), returns 0 if no effect, a positive integer otherwise
---
Duel.GetFlagEffectLabel(int player, int code) -> 
Gets the integer labels to the flag effect registered to the player (int player) with (int code) as the EffectCode, returns nil if there is no integer label.
---
Duel.GetFreeLinkedZone(int player) -> int
Gets all the unoccupied zones that (int player) has that Link Monsters points to
---
Duel.GetFusionMaterial(int player) -> Group
Returns a group of cards that are usable as fusion materials by the players, those cards consist of cards in the player's monster zone and also in the player's hand, GY and spell/trap zone that are affected by an EFFECT_EXTRA_FUSION_MATERIAL effect.
---
Duel.GetLinkedGroup(int player, int location1, int location2) -> Group
Returns the group of cards in the specified locations that are pointed by a link card.
---
Duel.GetLinkedGroupCount(int player, int location1, int location2) -> int
Returns the number of cards that would be returned by Duel.GetLinkedGroup
---
Duel.GetLinkedZone(int player) -> int
Gets all the zones that (int player) has that Link Monsters points to
---
Duel.GetLocationCount(int player, int location, int use_player, int reason, int zone) -> int
Returns 2 values. First the number of zones that a player (target_player) has available in a location of the field (int location)[, that can be used by the player (use_player), with intention of (reason), among certain zones (zone)]. Second return is a flag with the available zones.
---
Duel.GetLocationCountFromEx(int player, int rplayer, Group|Card sg, Card|int lc, int zone) -> int
Gets the number of available zones that (int player) has to perform a Special Summon from the Extra Deck. Optional Parameters: int rplayer is the player performing the summon , by default comes from the player that activates the effect itself; sg are material(s) or tribute(s) for the special summon, it's included when the effect requires the cost of one or more cards; lc is the card that will be special summoned, it's included when it's a specific card which will be special summon). If lc is group, it cannot be passed directly. Instead, pass the type of the monsters in that group (e.g. TYPE_FUSION, see "Construct Element"), which is limited to a single type and will not work properly if the group has different types. The zone parameter is used to limit the check to only some specific zones of the field. The second return is a flag with the available zones.
---
Duel.GetLP(int player) -> int
Gets a specified player's (int player) current Life Point
---
Duel.GetMatchingGroup(function f, int player, int s, int o, Group|Card|nil ex, any ...) -> Group
Gets all cards in locations (int s) (on (int player)'s side of the field) and (int o) (on their opponent's) for which (function f) returns true, except (Card ex)
---
Duel.GetMatchingGroupCount(function f, int player, int s, int o, Group|Card|nil ex, any ...) -> int
Returns the number of cards that would be returned by Duel.GetMatchingGroup
---
Duel.GetMatchingGroupCountRush(function f, int player, int s, int o, Group|Card|nil ex, any ...) -> int
Same as Duel.GetMatchingGroupCount but exclude the left and right pieces of a summoned maximum monster
---
Duel.GetMatchingGroupRush(function f, int player, int s, int o, Group|Card|nil ex, any ...) -> int
Equivalent to Duel.GetMatchingGroup, but the cards are also filtered to match Auxiliary.FilterMaximumSideFunctionEx
---
Duel.GetMetatable(int code) -> table
Equivalent of calling _G["c" .. code], returns the global metatable associated with that card's code (the "s" returned by GetID)
---
Duel.GetMZoneCount(int target_player, Card|Group ex, int use_player, int reason, int zone) -> int
Gets the number of available Main Monster Zones of a player (target_player)[, excluding card|group (ex), that can be used by the player (use_player), with intention of (reason), among certain zones (zone)]    {note: Basically it is Duel.GetLocationCount that excludes}. The second return is a flag with the available zones.
---
Duel.GetOperatedGroup() -> Group
Gets the last group of operated cards (from last call of some functions, ex. calling this after Duel.Draw would return a group of the drawn cards)
---
Duel.GetOperationCount(int chainc) -> int
Get the amount of operation info set by previous calls to Duel.SetOperationInfo for the corresponding chain.
---
Duel.GetOperationInfo(int chainc, int category) -> bool
Returns the corresponding values that were set by a previous call to Duel.SetOperationInfo for the corresponding category. If the first return value is true that means that operation info was set and then there will be 4 extra return values corresponding to the parameters of SetOperationInfo, otherwise only a single false value is returned.
---
Duel.GetOverlayCount(int player, int s, int o) -> int
Returns the number of cards that would be returned by Duel.GetOverlayGroup
---
Duel.GetOverlayGroup(int player, int s, int o) -> Group
Returns the group of cards that are currently attached to monsters. (int player) is the reference player, and (int s) and (int o) check, respectively for your cards and your opponent's cards.
---
Duel.GetPlayerEffect(int player, int effect_type) -> Effect
Returns all the effect with that code (int effect_type) applied on the player. With no effect_type or effect_type=0 it will return all the effects applied on the player. [effect_type refer to "EFFECT_" constants, eg: EFFECT_REVERSE_DAMAGE, EFFECT_CANNOT_MSET]
---
Duel.GetPlayersCount(int team) -> int
Get the amount of player for that specific team. (Can be used to deduce if the duel is an "n vs m" duel and also in conjunction with Duel.TagSwap to "iterate" all the players in the duel.)
---
Duel.GetPossibleOperationInfo(int chainc, int category) -> bool
Behaviour similar to Duel.GetOperationInfo, but returns the value set by Duel.SetPossibleOperationInfo instead
---
Duel.GetRandomNumber(int min, int max) -> int
Gets a random number between min (default is 0) and max.
---
Duel.GetReleaseGroup(int player, bool use_hand, bool use_oppo, int reason) -> Group
Returns the group of cards that can be used as tribute **NOT** for a Tribute Summon
---
Duel.GetReleaseGroupCount(int player, bool use_hand, bool use_oppo, int reason) -> int
Returns the number of cards that would be returned by Duel.GetReleaseGroup
---
Duel.GetRitualMaterial(int player, bool checklevel) -> Group
Returns cards that are usable by (int player) as ritual materials. if (bool checklevel) is true, only cards with level greater than 0 will be returned
---
Duel.GetStartingHand(int player) -> int
Gets a specified player's (int player) starting hand
---
Duel.GetTargetCards(Effect e) -> Group
Returns a group containing the targeted cards of (Effect e)'s activation and that are still related to that specific effect
---
Duel.GetTargetCount(function f, int player, int s, int o, Group|Card|nil ex, any ...) -> int
Returns the number of targets, except (Group/Card ex), that match (function f), taking (int player) as the referential player, in locations defined in (int s) for your cards and (int o) for opponent's.
---
Duel.GetTributeCount(Card c, Group mg, bool ex) -> int
Returns the number of cards that are usable for a tribute summon by c's controller. By default it only check the controller's field and opponent's cards with an extra release effects applied to them. If ex is true then all the cards on the opposing side of the field are considered regardless. If mg is passed, the cards are picked only among that group. **deprecated and should not be used**
---
Duel.GetTributeGroup(Card c) -> Group
Returns the cards that are usable for a tribute summon of c.
---
Duel.GetTurnCount(int tp) -> int
Gets the turn count, if tp is passed, it returns the turn count for that specific player (so if the current turn count is 5, a player's turn count would be 2 or 3)
---
Duel.GetTurnPlayer() -> int
Returns the turn player (0 for the player who went first, 1 for the other)
---
Duel.GetUsableMZoneCount(int target_player, int using_player) -> int
Gets the number of Monster Zones that are usable by (int using_player) on (int target_player)'s field.
---
Duel.GetZoneWithLinkedCount(int count, int tp) -> int
Returns a zone flag including the tp's zones that are pointed by at least "count" Link Monsters.
---
Duel.GoatConfirm(int tp, int loc) -> 
Used for goat versions of cards, handle the "fail to find" scenario. It confirms tp's LOCATION_DECK or LOCATION_HAND (passed in loc), the hand is revealed to the opposing player, the deck is revealed to tp.
---
Duel.GrabSelectedCard() -> Group
Returns the group of cards that was set by a previous Duel.SetSelectedCard call. The group of selected cards is cleared in the core.
---
Duel.HasFlagEffect(int tp, int id, int ct) -> bool
Returns if (int tp) has a flag with id equal to (int id) register to it. If (int ct) is provided checks if it the flags was registered at least that many times.
---
Duel.Hint(int hint_type, int player, int desc) -> 
Creates a message for the "player" which has "type" as key and "desc" as value. It is entirely up to the client to interpret say data, the most common case is setting the selection message with, "type" being "HINT_SELECTMSG" and "desc" being a stringId. It is also used to implement Skill Cards visually. Check the "HINT_XXX" constants for their behaviour.
---
Duel.HintSelection(Card|Group selection, bool log_as_selection) -> 
If log_as_selection is true, that selection will be logged by the client as "card(s) selected" rather than "card(s) targeted"
---
Duel.IncreaseSummonedCount(Card c) -> 
Increases the number of normal summons/sets performed by the turn player. If a card is passed and that card has an EFFECT_EXTRA_SUMMON_COUNT applied to it, that effect is used instead of increasing the count of the turn player.
---
Duel.IsAbleToEnterBP() -> bool
Checks if the player can enter BP this turn. This function returns true when eother of these is true: - it is not the first turn of the duel, - the DuelMode flag DUEL_ATTACK_FIRST_TURN is set, - the turn player is affected by EFFECT_BP_FIRST_TURN and that player is not affected by EFFECT_CANNOT_BP and the current phase is lower than PHASE_BATTLE_START.
---
Duel.IsAttackCostPaid() -> int
Returns the status of payment of attack cost for a card (e.g. Mist Valley Falcon). A return value of 0 means that the attack cost hasn't been paid yet, so it can be canceled by the current effect, 1 means the attack cost has been paid by at least 1 previous card, so it HAS TO be paid and cannot be canceled, 2 means that the attack cost has been canceled by a previous effect and thus HAS TO NOT be paid nor canceled, just ignored.
---
Duel.IsBattlePhase() -> bool
Returns if the current phase is the Battle Phase (between PHASE_BATTLE_START and PHASE_BATTLE)
---
Duel.IsCanAddCounter(int player, int countertype, int count, Card c) -> bool
If only (int player) is passed, it checks if that player is not affected by "EFFECT_CANNOT_PLACE_COUNTER" that doesn't have a specific target (and thus no extra checks). If all the other 3 parameters are provided, it checks if that player is affected by "EFFECT_CANNOT_PLACE_COUNTER" effects with those parameters as arguments.
---
Duel.IsCanRemoveCounter(int player, int s, int o, int countertype, int count, int reason) -> bool
Checks if a player (int player) can remove counter(s) (int countertype) (int count) from the field with a reason (int reason). The variables int s and int o are the player's and the opponent's field, respectively, 0 to exclude and nonzero to include.
---
Duel.IsChainDisablable(int chainc) -> bool
Checks if a chain's (int chainc) effect can be disabled (Negate Effect)
---
Duel.IsChainNegatable(int chainc) -> bool
Checks if a chain's (int chainc) effect activation can be negated (Negate Activation)
---
Duel.IsChainSolving() -> bool
Checks if there is a chain currently resolving. (retrieves the processor's chain_solving data member, without calling any function)
---
Duel.IsDamageCalculated() -> bool
Returns true if damage has been calculated during the current (or previous) damage calculation, otherwise returns false
---
Duel.IsDuelType(int flag) -> bool
Check if the current duel flags match the passed ones. (Check the "DUEL_XXX" constants for the available flags)
---
Duel.IsEnvironment(int code, int player, int location) -> bool
Depending on the location and player passed checks if there's: - a Field Spell with its effects applied in the field zone OR - a card with its effects applied that correspond to the code. If there are no field spells in play and LOCATION_FZONE or LOCATION_SZONE are passed, effects that treats as if a field spell is in play (e.g. "Maiden of the Aqua") are also checked.
---
Duel.IsExistingMatchingCard(function f, int player, int s, int o, int count, Group|Card|nil ex, any ...) -> bool
Checks if (int count) cards exist in locations (int s) (on (int player)'s side of the field) and (int o) (on their opponent's) for which (function f) returns true, except (Card ex)
---
Duel.IsExistingTarget(function f, int player, int s, int o, int count, Group|Card|nil ex, any ...) -> bool
This function's behaviour is equivalent of calling Duel.IsExistingMatchingCard with the same arguments and filtering cards with Card.IsCanBeEffectTarget with the current reason effect as parameter (internal to the core, but most of the time corresponds to the effect itself)
---
Duel.IsMainPhase() -> bool
Returns if the current phase is either Main Phase 1 or Main Phase 2.
---
Duel.IsPhase(int phase) -> bool
Returns if the current phase is the equal to (int phase)
---
Duel.IsPlayerAffectedByEffect(int player, int code) -> Effect|nil
Returns the first instance of an effect affecting the player corresponding to the passed code, nil if there's none. The return can be used as boolean check with an Effect being returned as true and nil being returned as false.
---
Duel.IsPlayerCanAdditionalSummon(int player) -> bool
Returns if the player can perform an additional normal summon via a EFFECT_EXTRA_SUMMON_COUNT (e.g. "Fire Formation - Tensu")
---
Duel.IsPlayerCanDiscardDeck(int player, int count) -> bool
Checks if a player (int player) can mill a number of cards (int count) from their Deck
---
Duel.IsPlayerCanDiscardDeckAsCost(int player, int count) -> bool
Checks if a player (int player) can mill a number of cards (int count) from their Deck as cost
---
Duel.IsPlayerCanDraw(int player, int count) -> bool
If (int count) is not provided, checks if the provided player (int player) can draw cards from the deck (i.e if it is not affected by EFFECT_CANNOT_DRAW). If (int count) is provided and it is not 0, additionally checks if the player has at least that many cards in the deck.
---
Duel.IsPlayerCanFlipSummon(int player, Card c) -> bool
Checks if (int player) can Flip Summon (Card c)
---
Duel.IsPlayerCanPendulumSummon(int player) -> bool
Returns if the player can perform a pendulum summon. (equivalent of calling Duel.IsPlayerCanProcedureSummonGroup(player,SUMMON_TYPE_PENDULUM))
---
Duel.IsPlayerCanProcedureSummonGroup(int player, int sumtype) -> bool
Checks if the player is affected by a EFFECT_SPSUMMON_PROC_G effect whose SummonType value is sumtype.
---
Duel.IsPlayerCanRelease(int player, Card c, int reason) -> bool
If c is not passed, only checks if the player is not affected by EFFECT_CANNOT_RELEASE, otherwise checks if the player can Tribute the passed card, with the passed reason.
---
Duel.IsPlayerCanRemove(int player, Card c) -> bool
If c is not passed, only checks if the player is not affected by EFFECT_CANNOT_REMOVE, otherwise checks if the player can banish the passed card.
---
Duel.IsPlayerCanSendtoDeck(int player, Card c) -> bool
If c is not passed, only checks if the player is not affected by EFFECT_CANNOT_TO_DECK, otherwise checks if the player can return the passed card to the deck.
---
Duel.IsPlayerCanSendtoGrave(int player, Card c) -> bool
If c is not passed, only checks if the player is not affected by EFFECT_CANNOT_TO_GRAVE, otherwise checks if the player can send the passed card to the GY.
---
Duel.IsPlayerCanSendtoHand(int player, Card c) -> bool
If c is not passed, only checks if the player is not affected by EFFECT_CANNOT_TO_HAND, otherwise checks if the player can send the passed card to the Hand.
---
Duel.IsPlayerCanSpecialSummon(int player, int sumtype, int sumpos, int target_player, Card c) -> bool
If only the player is passed as parameter, it checks if the player is affected by any effect that would prevent him to special summon a monster, otherwise checks if the player can Special Summon "c" as "sumtype", to "target_player"'s field in the passed position.
---
Duel.IsPlayerCanSpecialSummonCount(int player, int count) -> bool
Checks if the player can Special Summon "count" times.
---
Duel.IsPlayerCanSpecialSummonMonster(int player, int code, int|table setcode, int type, int atk, int def, int level, int race, int attribute, int pos, int target_player, int sumtype) -> bool
Checks if the player can special summon a monster as "sumtype", with the specified stats, in "pos" on "target_player"'s field. The stats are read as "code"'s default stats, if the stat parameters are not passed are passed as nil, they are not overwritten from the base stats, otherwise the new passed value will be used as stat for the card. "setcode" can be both an int with multiple setcodes encoded in a single value (by bit shifting them, but with a max of 4 setcodes) or as a table, with each entry representing a separate setcode.
---
Duel.IsPlayerCanSummon(int player, int sumtype, Card c) -> bool
If only the player is passed, checks if the player is not affected by EFFECT_CANNOT_SUMMON, otherwise checks if the player can Normal Summon the passed card as the passed SummonType.
---
Duel.IsSummonCancelable() -> bool
Returns if the current summon procedure is cancelable, as in it's a summon done outside a chain in an open game state and it's not being performed during a chain or as a part of a separate effect.
---
Duel.IsTurnPlayer(int player) -> bool
Checks if the current turn is (int player)'s turn.
---
Duel.LinkSummon(int player, Card c, Group|Card|nil must_use, Group|Card|nil mg, int minc, int maxc) -> 
A player (int player) Link Summons a card (Card c) using "must_use" as part of its materials, choosing among "mg", with "min" and "max" materials to be used for the Summon.
---
Duel.LoadCardScript(string|int code) -> 
Loads into the current environment (duel/puzzle) the script from card which id is int code. If a string is used, it must be "c'code'.lua"
---
Duel.LoadCardScriptAlias(int code) -> 
Loads the target's card metatable in the duel, and makes so that the current loaded one gets replaced by it. This will basically make the script that called this function behave like script loading for alternate artworks (to deal with problems of loading aliased cards)
---
Duel.LoadScript(string file_name, bool forced) -> bool
Loads into the current environment (duel/puzzle) (file_name)'s script, and return true or false depending on the script loading success. If "forced" is false, the file name is loaded only if it hasn't been loaded before. If "forced" is true, other than loading the script regardless if it has been loaded previously, the 2nd returned value will be whatever was set as the global variable "edopro_export" from the loaded script.
---
Duel.MajesticCopy(Card c1, Card c2, int reset_value, int reset_count) -> 
Copies c1's effect to c2 allowing c2 to use c1's activated effects. If reset_value and reset_count are provided, use those parameter as reset parameters for the copied effects (reset_value default value is RESET_EVENT|0x1fe0000|RESET_PHASE|PHASE_END |RESET_SELF_TURN|RESET_OPPO_TURN). This is an ad hoc function for Majestic Star Dragon.
---
Duel.MoveSequence(Card c, int seq, int location) -> 
Moves a card (Card c) to a different sequence (int seq). If (int location) is not provided, only the current location is considered
---
Duel.MoveToDeckBottom(int|Card|Group targets, int player) -> 
Places the passed cards in the deck to the bottom of player's deck. If the argument is an integer then it moves the top n cards from player's deck.
---
Duel.MoveToDeckTop(Card|Group targets) -> 
Places the passed cards to the top of the deck.
---
Duel.MoveToField(Card c, int move_player, int target_player, int dest, int pos, bool enabled, int zone) -> bool
A player (int move_player) moves a card (Card c) to the target player's field. The destination must be either LOCATION_MZONE or LOCATION_SZONE (maybe LOCATION_ONFIELD too). It will be sent with the given position (int pos). Its effects will either be enabled or disabled according to the last parameter (bool enabled), if zone is specified, it can only place the card in these zones.
---
Duel.MSet(int player, Card c, bool ignore_count, Effect|nil e, int min, int zone) -> 
A player Sets a card (Card c) to the provided zone, using Normal Summon proc that the card has. if ignore_count is true, the Set would not count towards the standard limit of Normal Summon/Set. If an effect (Effect e) is provided, the Normal Set is counted as a Set by that effect. if min>0 then the Set proc must need that amount or more tributes. If zone is provided, the card will be settable only to the specific zones.
---
Duel.NegateActivation(int chainc) -> bool
Negates the activation of an effect in a chain corresponding to that specific chain link.
---
Duel.NegateAttack() -> bool
Negates the current attack. Has no effect if the game has confirmed battle (about to enter Damage Step)
---
Duel.NegateEffect(int chainc) -> bool
Negates the effect in a chain corresponding to that specific chain link.
---
Duel.NegateRelatedChain(Card c, int reset) -> 
Negates all effects activation in a chain related to a card. This effect negation is reset based on the reset flag passed. (e.g. with RESET_TURN_SET the activations would not be disabled if the card were to be set facedown in that chain.)
---
Duel.NegateSummon(Card|Group targets) -> 
Negates the summon of a card or a group of cards
---
Duel.Overlay(Card c, Card|Group of_card, bool send_to_grave) -> 
Attachs (Card|Group of_card) to (Card c). By default, if any card in the 2nd parameter has materials attached to it as well, they'll also be attached to (Card c) automatically. If send_to_grave is true, they will instead be sent to the graveyard with REASON_RULE, if you want to do something else with those cards, you have to move them before calling this function.
---
Duel.PayLPCost(int player, int cost) -> 
Makes a player (int player) pay an amount (int cost) of LP
---
Duel.PendulumSummon(int player) -> 
Makes the player perform a Pendulum Summon. (equivalent to calling Duel.ProcedureSummon(player,SUMMON_TYPE_PENDULUM)
---
Duel.PlayFieldSpell(Card c, any e, any tp, any eg, any ep, any ev, any re, any r, any rp, any target_p) -> bool
Function deprecated since version 40.0.0. Use "Duel.ActivateFieldSpell" instead
---
Duel.ProcedureSummon(int player, int sumtype, Card c, Group|Card|nil must_use, Group|Card|nil mg, int minc, int maxc) -> 
A player (int player) "Procedure Summons" (the SummonType performed is determined by the corresponding parameter) a card (Card c) using "must_use" as part of its materials, choosing among "mg", with "min" and "max" materials to be used for the Summon.
---
Duel.ProcedureSummonGroup(int player, int sumtype) -> 
Makes the player perform a summon using a field effect EFFECT_SPSUMMON_PROC_G
---
Duel.RaiseEvent(Group|Card eg, int code, Effect re, int r, int rp, int ep, int ev) -> 
Raises a specific event that will raise effects of type EFFECT_TYPE_FIELD, by relying re,r,rp,ep,ev as the arguments of that event with eg being the cards that were the reason of that event.
---
Duel.RaiseSingleEvent(Card ec, int code, Effect re, int r, int rp, int ep, int ev) -> 
Raises a specific event that will raise effects of type EFFECT_TYPE_SINGLE on the specific ec, by relying re,r,rp,ep,ev as the arguments of that event.
---
Duel.RDComplete() -> 
Complete Damage/Recover step (for simultaneous damage/recovery)
---
Duel.Readjust() -> 
Makes the game do the adjustments ( win, disable, control, self destroy, equip, position, trap monster). Calling this while adjusting (most likely, in EVENT_ADJUST) four times with the same card (calling this will raise EVENT_ADJUST at the end, so it is possible to loop) will make the card instantly destroyed.
---
Duel.Recover(int player, int value, int reason, bool is_step, int rp) -> int
Increases player's (int player) Life Points by an amount (int value) for a reason (int reason). The LP increase is considered to be done by (int rp). Setting (bool is_step) to true makes so the recovery is considered being done at the call of Duel.RDComplete().
---
Duel.RegisterEffect(Effect e, int player) -> 
Registers an effect (Effect e) to a player (int player)
---
Duel.RegisterFlagEffect(int player, int code, int reset_flag, int property, int reset_count, int label) -> Effect
Registers a flag effect to a player (int player) with (int code) as the EffectCode
---
Duel.Release(Card|Group targets, int reason, int rp) -> int
Tribute a card(s) (Card|Group targets) with listed reason (int reason). If (int rp) is provided, sets the reason player to be that player. Returns the number of cards successfully Tributed.
---
Duel.ReleaseRitualMaterial(Group g) -> 
Tributes monsters from (Group g) for a Ritual Summon
---
Duel.Remove(Card|Group targets, int|nil pos, int reason, int player, int rp) -> int
Banishes a card or group (Card|Group targets) in position as supplied by (int pos) (nil means their current position), with (int reason) as reason, if (int player) is supplied, the destination would be that player's zone. If (int rp) is provided, sets the reason player to be that player. Returns the number of cards successfully banished.
---
Duel.RemoveCards(Card|Group cards) -> 
Removes the passed cards from the duel.
---
Duel.RemoveCounter(int player, int s, int o, int countertype, int count, int reason) -> bool
Makes a player (int player) remove counter(s) (int countertype) (int count) from the field with a reason (int reason). The variables int s and int o are the player's and the opponent's field, respectively, 0 to exclude and 1 (or higher) to include.
---
Duel.RemoveOverlayCard(int player, int s, int o, int min, int max, int reason, Group rg) -> int
Player (int player) removes cards attached, from your field (int s) and/or opponent's  (int o), with a minimum of (int min), and a maximum of (int max), with reason (int reason). If Group rg is provided, then the player removes only from monsters in that group. Returns the number of cards removed
---
Duel.ResetFlagEffect(int player, int code) -> 
Resets a flag with (int code) as the EffectCode from a player (int player)
---
Duel.ReturnToField(Card c, int pos, int zone) -> bool
Return a card (Card c) to the field (only valid for cards that leaves the field with REASON_TEMPORARY, pos denotes the return position (if not specified, uses the card's previous position on field)
---
Duel.RockPaperScissors(bool redo) -> int
Has players play a game of Rock Paper Scissors. Return player (winner or PLAYER_NONE). If redo == true, RPS continues until there is a winner, otherwise RPS is only played once.
---
Duel.SelectCardsFromCodes(int sel_player, int min, int max, bool cancelable, bool return_index, int code1, any ...) -> table
Make (int sel_player) select between (int min) and (int max) cards among the passed card codes. If cancelable is true and the selection is canceled nil will be returned. If return_index is true a number of tables equal to the number of selected cards will be returned, each table will have the selected code index (starting by 1) as the first element and the code itself as second element. Otherwise the selected codes will be returned as multiple return values.
---
Duel.SelectDisableField(int player, int count, int location_player, int location_oppo, int filter, bool all_field) -> int
Asks (int player) to select zones to be disabled, a number of zones up to (int count), in locations (location_player) for the player and (location_oppo) for their opponent, that are bitmasked by (int filter). In another word, zones that are not filter. If all_field is true the player can select any zones, including Pendulum and Extra Monster Zone which are normally not allowed.
---
Duel.SelectEffect(int player, any ...) -> int|nil
Makes player (int player) select 1 option among possible effects. The ellipsis (...) allows tables in the form {bool condition, int stringid}. The function then makes the player select an effect, displaying the strings whose conditions are true, returning the index of the chosen element or nil.
---
Duel.SelectEffectYesNo(int player, Card c, int description) -> bool
Asks (int player) Yes or No, with the question being specified by (int desc) highlighting the passed card (Card c). The default string ask the player if they want to use the effect of "card x"
---
Duel.SelectFieldZone(int player, int count, int s, int o, int filter) -> int
Asks (int player) to choose a number of Zones up to (int count), in locations (int s) for the player and (int o) for their opponent, that are bitmasked by (int filter) <in another word, zones that are not filter>. This function allows the player to select ANY field zone, even those that are currently occupied by other cards.
---
Duel.SelectFusionMaterial(int player, Card c, Group materials, Card|Group|nil must_use, int chkf) -> Group
Makes the player select the fusion materials among the passed group for the fusion summon of the passed card and returns such group (this function filters the various EFFECT_FUSION_MATERIAL effects registered on the card). If must_use is provided, those cards should be materials forced for that fusion summon, chkf is a value keeping the player whose field is to check, with optional FUSPROC_XX flags or'ed to it.
---
Duel.SelectMatchingCard(int sel_player, function f, int player, int s, int o, int min, int max, any cancelable, Group|Card|nil ex, any ...) -> Group
Makes (int sel_player) select between a minimum and maximum (int min, int max) number of cards in locations (int s) (on (int player)'s side of the field) and (int o) (on their opponent's) for which (function f) returns true, except (Card ex). If cancelable is true and the selection is canceled nil will be returned. If both cancelable and a minimum of 0 are passed, the result is unspecified.
---
Duel.SelectOption(int player, bool confirm_dialog, int desc1, any ...) -> int
Allows (int player) to choose between any number of options, starting with (int desc1). Returns the index of the chosen option, e.g. desc1 returns 0, the second option returns 1, etc. If confirm_dialog is false, the announce will be performed, but the no selection hint will be shown to the opponent
---
Duel.SelectPosition(int player, Card c, int pos) -> int
Makes int player select a position int pos for card c
---
Duel.SelectReleaseGroup(int sel_player, function f, int min, int max, bool use_hand, bool cancelable, bool check_field, Card card_to_check, int to_player, int zone, bool use_oppo, Group|Card|nil ex, any ...) -> Group
Selects monsters to be tributed by int sel_player, applying the same filtering rules as Duel.CheckReleaseGroup. If cancelable is true and the selection is canceled nil will be returned.
---
Duel.SelectReleaseGroupCost(int player, function f, int min, int max, bool use_hand, function specialchk, Card|Group|nil ex, any ...) -> Group
Selects monsters to be tributed by int sel_player, applying the same filtering rules as Duel.CheckReleaseGroupCost.
---
Duel.SelectReleaseGroupEx(int player, function f, int min, int max, bool use_hand, bool cancelable, bool check_field, Card card_to_check, int to_player, int zone, bool use_oppo, Group|Card|nil ex, any ...) -> Group
Selects monsters to be tributed by int sel_player, applying the same filtering rules as Duel.CheckReleaseGroupEx. If cancelable is true and the selection is canceled nil will be returned.
---
Duel.SelectReleaseGroupSummon(Card c, int player, Effect e, function fil, int min, int max, function last, any ...) -> bool
(To be added)
---
Duel.SelectTarget(int sel_player, function f, int player, int s, int o, int min, int max, any cancelable, Group|Card|nil ex, any ...) -> Group
This function's behaviour is equivalent of calling Duel.SelectMatchingCard with the same arguments and filtering cards with Card.IsCanBeEffectTarget with the current reason effect as parameter (internal to the core, but most of the time corresponds to the effect itself)
---
Duel.SelectTribute(int player, Card c, int min, int max, Group mg, int to_player, int zone, bool cancelable) -> Group
Makes (int player) select a (int min) and (int max) number of tributes to be used for (Card c) to be summoned in the passed zones to to_player's field by also forcefully selecting the cards from mg. If cancelable is true and the selection is canceled, nil will be returned.
---
Duel.SelectYesNo(int player, int desc) -> bool
Asks (int player) Yes or No, with the question being specified by (int desc)
---
Duel.Sendto(Card|Group c, int location, int reason, int pos, int player, int sequence, int rp) -> int
Sends a card or group (Card|Group targets) to the location (int location) with (int reason) as reason in (ins pos) position (only applies in Extra Deck and Banish). If (int player) is supplied, the destination would be that player's location. A seq value of 0 means it's put on the top, 1 means it's put on the bottom, other values means it's put on the top, and then if it is in the Deck, it will be shuffled after the function resolution, except if Duel.DisableShuffleCheck() is set to true beforehand. If (int rp) is provided, sets the reason player to be that player. Returns the number of cards successfully sent.
---
Duel.SendtoDeck(Card|Group targets, int|nil player, int seq, int reason, int rp) -> int
Sends a card or group (Card|Group targets) to the Deck with (int reason) as reason, if (int player) is supplied, the destination would be that player's Deck. If (int rp) is provided, sets the reason player to be that player. Available sequence values (SEQ_DECKTOP, SEQ_DECKBOTTOM and SEQ_DECKSHUFFLE). If SEQ_DECKSHUFFLE or other values are used for the sequence, the card is put on the top, and the Deck will be shuffled after the function resolution, except if Duel.DisableShuffleCheck() is set to true beforehand. Returns the number of cards successfully sent to the Deck.
---
Duel.SendtoExtraP(Card|Group targets, int|nil player, int reason, int rp) -> int
Sends a card or group (Card|Group targets) to the Extra Deck face-up with (int reason) as reason, if (int player) is supplied, the destination would be that player's Extra Deck (for Pendulum monsters only). If (int rp) is provided, sets the reason player to be that player. Returns the number of cards successfully sent.
---
Duel.SendtoGrave(Card|Group targets, int reason, int player, int rp) -> int
Sends a card or group (Card|Group targets) to the Graveyard with (int reason) as reason, if (int player) is supplied, the destination would be that player's Graveyard. If (int rp) is provided, sets the reason player to be that player. Returns the number of cards successfully sent.
---
Duel.SendtoHand(Card|Group targets, int|nil player, int reason, int rp) -> int
Sends a card or group (Card|Group targets) to the Hand with (int reason) as reason, if (int player) is supplied, the destination would be that player's hand. If (int rp) is provided, sets the reason player to be that player. Returns the number of cards successfully sent.
---
Duel.SetChainLimit(function f) -> 
Sets a function for limiting effects that could chain from this point in the chain, removed when an effect is chained to the current chain. Function f accepts at most 3 parameters [f(e,tp,p)] in which e is the effect that would be chained, tp is the same tp from the effect function where this function is called, and p is the player who would activate the would-be chaining effect.
---
Duel.SetChainLimitTillChainEnd(function f) -> 
Sets a function for limiting effects that could chain from this point for the chain until the end of the chain. Function f accepts at most 3 parameters [f(e,tp,p)] in which e is the effect that would be chained, tp is the same tp from the effect function where this function is called, and p is the player who would activate the would-be chaining effect.
---
Duel.SetCoinResult(int res, any ...) -> 
Changes the results of the latest executed coin tosses to the provided values.
---
Duel.SetDiceResult(int res, any ...) -> 
Changes the result of the latest executed dice rolls to the provided values.
---
Duel.SetFlagEffectLabel(int player, int code, int label) -> bool
Assigns an integer (int label) number to the flag effect registered to the player (int player) with (int code) as the EffectCode. Returns true if a flag effect with such code existed and the label was set.
---
Duel.SetFusionMaterial(Group g) -> 
Sets the internal group of selected fusion materials, this function is to be used in EFFECT_SUMMON_MATERIAL after the materials are selected, as this group is what will then be returned from Duel.SetFusionMaterial
---
Duel.SetLP(int player, int lp) -> 
Sets a specified player's (int player) current Life Point to (int lp). (Used by effects that "make the LP become X")
---
Duel.SetOperationInfo(int chainc, int category, Card|Group targets, int count, int target_player, int target_param) -> 
Sets informations about the operation being performed in the current (int chainc = 0) chain, belonging to (int category), with a total of (int count) of card(s) from (Card|Group targets) being affected. These are used with GetOperationInfo. Also, the parameter passed here are checked if any of the summon related activities are checked like ACTIVITY_SUMMON, ACTIVITY_NORMALSUMMON, ACTIVITY_SPSUMMON and ACTIVITY_FLIPSUMMON.
---
Duel.SetPossibleOperationInfo(int chainc, int category, Card|Group targets, int count, int target_player, int target_param) -> 
Behavior similar to Duel.SetOperationInfo, but those properties are stored separately and are meant to be set for cards that "could" perform such action (for example for cards that include an effect that can be negated by Ghost Belle)
---
Duel.SetSelectedCard(Card|Group cards) -> 
Sets the current selected cards that are to be used by Group.Select/CheckWithSumGreater and Group.Select/CheckWithSumEqual, also by Duel.CheckReleaseGroup and Duel.CheckReleaseGroupEx
---
Duel.SetTargetCard(Card|Group targets) -> 
Sets the cards targeted by the current effect and creates a relation to them.
---
Duel.SetTargetParam(int value) -> 
Stores an arbitrary integer as the "target parameter" for the currently resolving chain, its uses vary depending on the type of effect, but for example with cards that damage/recover LP this value corresponds to the amount to gain/lose, so that other effects that change those amounts can access and change this value
---
Duel.SetTargetPlayer(int player) -> 
Used to set the "target player" for the currently resolving chain, its uses vary depending on the type of effect, but it's mostly used to indicate which player will be affected by such effect (see "Mystical Refpanel")
---
Duel.ShuffleDeck(int player) -> 
Shuffles the deck of (int player). Handled automatically if a card is sent to DeckSequence -2.
---
Duel.ShuffleExtra(int player) -> 
Shuffles the Extra Deck of (int player). Must be used after confirming cards in the Extra Deck.
---
Duel.ShuffleHand(int player) -> 
Shuffles the hand of (int player). Handled automatically after Duel.ConfirmCards().
---
Duel.ShuffleSetCard(Group g) -> 
Shuffles the set cards in (Group g). (Shifting Shadows). All the cards must be from the same location. The only supported locations are the Main Monster Zone and the Spell & Trap Zone.
---
Duel.SkipPhase(int player, int phase, int reset_flag, int reset_count, int value) -> 
Makes the specified player (int player) skips the encountered phase (int phase), the effect is reset when reset_flag is met reset_count times. (int value) sets the skip effect's value (don't know what it's used for though...)
---
Duel.SortDeckbottom(int sort_player, int target_player, int count) -> 
Player (int sort_player) sorts an amount of cards (int count) of a player's (int target_player) deck bottom
---
Duel.SortDecktop(int sort_player, int target_player, int count) -> 
Player (int sort_player) sorts an amount of cards (int count) of a player's (int target_player) deck top
---
Duel.SpecialSummon(Card|Group targets, int sumtype, int sumplayer, int target_player, bool nocheck, bool nolimit, int pos, int zone) -> int
A player (int sumplayer) Special Summons a card/group of cards (Card|Group targets) with SummonType described with SUMMON_TYPE_x (int sumtype) to a player's (int target_player) field in the specific zone (here zone 0xff, means the default zones). If (bool nocheck) is true, it will summon ignoring conditions. If (bool nolimit) is true, it will summon ignoring the revive limit. Returns the number of cards successfully summoned.
---
Duel.SpecialSummonComplete() -> 
Completes Special Summons conducted with Duel.SpecialSummonStep. This has to be called even if all the Duel.SpecialSummonStep fails.
---
Duel.SpecialSummonRule(int player, Card c, int sumtype) -> 
A player (int player) Special Summons a card (Card c) using Special Summon proc that the card has that matches the provided SummonType (0 means any).
---
Duel.SpecialSummonStep(Card c, int sumtype, int sumplayer, int target_player, bool nocheck, bool nolimit, int pos, int zone) -> bool
A player (int sumplayer) Special Summons a card (Card c) with SummonType described with SUMMON_TYPE_x (int sumtype) to a player's (int target_player) field in the specific zone (here zone 0xff, means the default zones). If (bool nocheck) is true, it will summon ignoring conditions. If (bool nolimit) is true, it will summon ignoring the revive limit. When a card is summoned this way, its summon is not considered complete until a call to Duel.SpecialSummonComplete is performed, this is useful when effects are to be applied to the card after it is "summoned" but before it "reaches the field".
---
Duel.SSet(int player, Card|Group targets, int target_player, bool confirm) -> int
Sets a card(s) to the Spell & Trap Zone or Field Zone. Can be used to Set Spells/Traps, as well as monsters with an effect that allows them to be Set in the Spell & Trap Zone (e.g. the "Artifact" monsters).
---
Duel.Summon(int player, Card c, bool ignore_count, Effect|nil e, any min, int zone) -> 
Makes a player (int player) Normal Summons a card (Card c) using the Normal Summon procedure that the card has. If (ignore_count) is set to true, the Summon would not count towards the standard limit of Normal Summon/Set. If an effect (Effect e) is provided, the Normal Summon is counted as a Summon by that effect. If (min) is greater than 0, the Summon proc must need that amount or more tributes. If zone is provided, the card will be summonable only to the specific zones.
---
Duel.SummonOrSet(int tp, Card c, bool ignore_count, Effect|nil e, int min) -> 
Makes player (int tp) Normal Summon or Set (Card c) by calling simultaneously Duel.Summon and Duel.MSet. If (Effect e) is not nil, checks if the summon can be done by that effect. If (bool ignore_count) is true, it ignores the standard once per turn summon limit. (int min) is the minimum number of tributes that are required.
---
Duel.SwapControl(Card|Group c1, Card|Group c2, int reset_phase, int reset_count) -> bool
Swaps control of 2 cards or 2 groups. If groups are provided they must contain the same number of cards and each group must contains cards on the same side of the field. If reset_phase and reset_count is specified, will behave like other effects with those resets (and so, the control will be returned when the effect has expired). Works only for monsters in Monster Zone.
---
Duel.SwapDeckAndGrave(int player) -> 
Swaps the cards from (int player)'s GY with the cards from his deck. This is an ad hoc function for Exchange of the Spirit.
---
Duel.SwapSequence(Card c1, Card c2) -> 
Exchanges the positions of two cards in the same location on the same side of the field.
---
Duel.SynchroSummon(int player, Card c, Group|Card|nil must_use, Group|Card|nil mg, int minc, int maxc) -> 
A player (int player) Synchro Summons a card (Card c) using "must_use" as part of its materials, choosing among "mg", with "min" and "max" materials to be used for the Summon
---
Duel.TagSwap(int team) -> 
If the current team has more than 1 player, switches to the next player of that team.
---
Duel.TossCoin(int player, int count) -> any
Tosses (int count) coins on behalf of (int player). Returns all the results of the tosses.
---
Duel.TossDice(int player, int count1, int count2) -> any
Rolls (int count1) dice on behalf of (int player) and (int count1) dice on behalf of the opponent of (int player). Returns all the results of the rolls.
---
Duel.Win(int player, int win_reason) -> 
Player (int player) wins the Duel for a reason (REASON_x). If the player is affected by EFFECT_CANNOT_LOSE_EFFECT the duel keeps going on.
---
Duel.XyzSummon(int player, Card c, Group|Card|nil must_use, Group|Card|nil mg, int minc, int maxc) -> 
A player (int player) Xyz Summons a card (Card c) using "must_use" as part of its materials, choosing among "mg", with "min" and "max" materials to be used for the Summon
---
CheckCountLimit(int tp) -> bool
Checks if the effect can still be used by tp or the player has finished its uses.
---
Clone(Effect e) -> Effect
Clone an effect object (Effect e), duplicating all except register status and assigned labels.
---
CreateEffect(Card c) -> Effect
Creates a new effect object with a card (Card c) as its owner.
---
CreateMysteruneQPEffect(any c, any id, any uniquecat, any uniquetg, any uniqueop, any rmcount, any uniqueprop, any uniquecode) -> Effect
(To be added)
---
CreateVernalizerSPEffect(any c, any id, any desc, any uniquecat, any uniquetg, any uniqueop) -> Effect
(To be added)
---
FromLuaRef(int ref) -> Effect
Returns a Effect object from a given lua reference. The function errors out if the reference is invalid or does not refer to a Effect object.
---
GetActivateLocation(Effect e) -> int
Gets (Effect e)'s location when it was activated.
---
GetActivateSequence(Effect e) -> int
Gets (Effect e)'s sequence when it was activated.
---
GetActiveType(Effect e) -> int
Gets an effect's (Effect e) CardType of activation effect. Activation type is often the effect handler's CardType, or the owner's if not attached to a card. Exception for Pendulum scale activation (would return TYPE_SPELL+TYPE_PENDULUM).
---
GetCategory(Effect e) -> int
Gets an effect's (Effect e) category
---
GetCode(Effect e) -> int
Gets (Effect e)'s code
---
GetCondition(Effect e) -> function
Gets an effect's (Effect e) condition function, returns nil if no function was set
---
GetCost(Effect e) -> function
Gets an effect's (Effect e) cost function, returns nil if no function was set
---
GetCountLimit(Effect e) -> int
Returns, in order, the following information's about (Effect e): remaining usages, maximum count limit, its hopt identifier (e.g. detects if "The effect of "card name" can only be used once per turn, almost always you'd want to use the card's own id to be sure it's unique.), its count flags (e.g. EFFECT_COUNT_CODE_DUEL to indicate an effect that is n times per duel), its hopt index (that is used to handle cards that have multiple hopt effects where each can be used once, the first will have an index of 0, the second an index of 1, etc,)
---
GetDescription(Effect e) -> int
Gets (Effect e)'s assigned description string id
---
GetFieldID(Effect e) -> int
Returns an effect's current unique instance ID. Each activation of an activated effect is a separate instance.
---
GetHandler(Effect e) -> Card
Gets an effect's (Effect e) card handler (that being the card on which the effect is registered on), if the effect is not attached to a card (i.e. registered to player) it returns its owner.
---
GetHandlerPlayer(Effect e) -> int
Returns the controller of the handler of the effect (Effect e). If the effect is registered to a player, it returns the player it's registered to instead.
---
GetHintTiming(Effect e) -> int
Returns a pair of integers with the hint timings set to Effect e. The first return value are the timings for the first player's turn and the second return are the hint timings set to the opponent
---
GetLabel(Effect e) -> int
Gets an effect's (Effect e) internal labels. If no labels are present, it will return 0.
---
GetLabelObject(Effect e) -> Card|Group|Effect|table
Gets an effect's (Effect e) internal label object
---
GetLuaRef(Effect e) -> int
Returns an integer representing the internal value used by lua to access the Effect e.
---
GetOperation(Effect e) -> function
Gets an effect's (Effect e) operation function, returns nil if no function was set
---
GetOwner(Effect e) -> Card
Gets an effect's (Effect e) card owner. If the effect was created as GlobalEffect then it returns an internal card object that shouldn't be used by the scripts.
---
GetOwnerPlayer(Effect e) -> int
Returns the controller of the owner of the effect (Effect e). If the effect is registered to a player, it returns the player it's registered to instead. If the owner was changed by Effect.SetOwnerPlayer, then it will return the value set by that function.
---
GetProperty(Effect e) -> int
Gets an effect's (Effect e) properties. The first return contains flags in the category EFFECT_FLAG_ while the second return value contains flags in the category EFFECT_FLAG2_ . A list of all the properties can be found in in constant.lua or defined in the core (effect_constants.h)
---
GetRange(Effect e) -> int
Gets an effect's range (the value defined in SetRange)
---
GetReset(Effect e) -> int
Gets (Effect e)'s reset flags and reset count.
---
GetTarget(Effect e) -> function
Gets an effect's (Effect e) target function, returns nil if no function was set
---
GetTargetRange(Effect e) -> int
Returns the pair of values set in (Effect e)'s SetTargetRange.
---
GetType(Effect e) -> int
Gets an effect's (Effect e) type
---
GetValue(Effect e) -> function|int
Gets an effect's (Effect e) value or value function, returns nil if no function was set
---
GlobalEffect() -> Effect
Creates a new effect object, not owned by any specific card.
---
IsActivatable(Effect e, int player, bool ignore_location, bool ignore_target) -> bool
Checks if an effect (Effect e) can be activated by a player (int player). If ignore location is true, the handler of the effect is not checked to be in a valid location for that effect to be activated. If ignore target is true, then the target function is not executed to check if the effect can be activated.
---
IsActivated(Effect e) -> bool
Returns if an effect (Effect e) is an activated effect. Effectively, this checks if the effect has any of the following types: EFFECT_TYPE_ACTIVATE, EFFECT_TYPE_FLIP, EFFECT_TYPE_IGNITION, EFFECT_TYPE_TRIGGER_O, EFFECT_TYPE_QUICK_O, EFFECT_TYPE_TRIGGER_F or EFFECT_TYPE_QUICK_F
---
IsActiveType(Effect e, int type) -> bool
Compares (with OR) an effect's (Effect e) CardType of activation effect with supplied type (int type). Activation type is often the handler's CardType, or the owner's if not attached to a card. Exception for Pendulum scale activation (would return TYPE_SPELL+TYPE_PENDULUM).
---
IsDeleted(Effect e) -> bool
Returns if the Effect object got internally deleted and remained as dangling reference inside the lua state.
---
IsHasCategory(Effect e, int cate) -> bool
Returns true if the effect (Effect e) has any category listed in (int cate), otherwise returns false
---
IsHasProperty(Effect e, int prop1, int prop2) -> bool
Returns true if the effect (Effect e) has any property listed in (int prop1) or (int prop2), otherwise returns false
---
IsHasType(Effect e, int type) -> bool
Returns true if the effect (Effect e) has any type listed in (int type), otherwise returns false
---
IsMonsterEffect(Effect e) -> bool
Returns if (Effect e) is a monster effect
---
IsSpellEffect(Effect e) -> bool
Returns if (Effect e) is a Spell effect
---
IsSpellTrapEffect(Effect e) -> bool
Returns if (Effect e) is an effect from a Spell or Trap card
---
IsTrapEffect(Effect e) -> bool
Returns if (Effect e) is a Trap effect
---
Reset(Effect e) -> 
Reset an effect (Effect e) and makes it collectible by the garbage collector. Even if the effect seems to be usable it **SHOULD NOT** be used in other places after calling this function.
---
SetAbsoluteRange(Effect e, int playerid, int s_range, int o_range) -> 
Sets an effect's (Effect e) target range in perspective of the supplied player (int playerid), s_range denotes the supplied player's range and o_range denotes the opponent's.
---
SetCategory(Effect e, int cate) -> 
Sets an effect's (Effect e) category. Refer to constant.lua for valid categories.
---
SetCode(Effect e, int code) -> 
Sets an effect's (Effect e) code. Refer to constant.lua and card scripts that has been already there for valid codes (or ask someone).
---
SetCondition(Effect e, function con_func) -> 
Sets (Effect e)'s condition function
---
SetCost(Effect e, function cost_func) -> 
Sets (Effect e)'s cost function
---
SetCountLimit(Effect e, int count, int code, int hopt_index, int flag) -> 
Sets an effect's (Effect e) use limit per turn to (int count). If "code" is supplied, then it would count toward all effects with the same CountLimitCode (i.e. Hard OPT). If a card has multiple HOPT effects on it, then instead of passing "code" as integer, a table can be used as parameter, the first element of this table will be still "code", the second element will instead be the HOPT index of that effect, this is done to prevent the passed code from clashing with other HOPT effects. (e.g. calling "e:SetCountLimit(1,1234)" is the same as calling "e:SetCountLimit(1,{1234,0})". The flag parameter consists of the "EFFECT_COUNT_CODE_XXX" constants.
---
SetDescription(Effect e, int desc) -> 
Sets an effect's (Effect e) description string id with (int desc), you can use aux.Stringid() to reference strings in your database, use the "HINTMSG_" constants, or directly put the string number you want (it's not always recommended, but it is possible if you need to use a system string that is defined in the strings.conf file but doesn't have an equivalent "HINTMSG_" constant).
---
SetHintTiming(Effect e, int s_time, int o_time) -> 
Sets (Effect e)'s client usage hint timing. This is the timing where the game will prompt the player to activate that effect (in addition to regular timings)
---
SetLabel(Effect e, int label, int ...) -> 
Sets an effect's (Effect e) internal labels to the integers passed as parameter (Multiple values and tables can used). This operation replaces previously set labels.
---
SetLabelObject(Effect e, Card|Group|Effect|table labelobject) -> 
Sets an effect's (Effect e) internal label object to label object. This operation replaces a previously stored label object.
---
SetOperation(Effect e, function op_func) -> 
Sets (Effect e)'s operation function.
---
SetOwnerPlayer(Effect e, int player) -> 
Sets (int player) as the (Effect e)'s owner player.
---
SetProperty(Effect e, int prop1, int prop2) -> 
Sets an effect's (Effect e) property. Refer to constant.lua and card scripts that has been already there for valid properties (or ask someone).
---
SetRange(Effect e, int range) -> 
Sets an effect's (Effect e) effective range (int range) i.e. LOCATION_MZONE. The location is the effect handler's location.
---
SetReset(Effect e, int reset_flag, int reset_count) -> 
Sets the timing that the effect (Effect e) would be erased (with reset_flag)
---
SetTarget(Effect e, function targ_func) -> 
Sets (Effect e)'s target function. In a activate effects, the target function is the function used to do the activation legality check and to execute steps that must be done during the activation (e.g. targeting cards, declaring names or numbers, etc).
---
SetTargetRange(Effect e, int s_range, int o_range) -> 
Sets (Effect e)'s target range, s_range denotes the effect's handler player's range and o_range denotes the opponent's. If the effect has "EFFECT_FLAG_PLAYER_TARGET" as property, then here 1 as "s_range" would mean it affect the handler and 0 would mean it doesn't, and "o_range" would refer to the opponent of the handler.
---
SetType(Effect e, int type) -> 
Sets an effect's (Effect e) type. constant.lua contains the list with all valid EffectTypes but other cards' scripts can be used as reference
---
SetValue(Effect e, function|int|bool val) -> 
Sets (Effect e)'s value, or value function
---
UseCountLimit(Effect e, int p, int count, bool oath_only) -> 
Decreases the remaining usages of the effect by the player "p" by "count", if "oath_only" is true, the function will do nothing unless the effect is an OATH effect.
---
Fusion.AddContactProc(Card c, function group, function op, function sumcon, function|nil condition, int sumtype, int|nil desc) -> 
Adds a Contact Fusion Procedure to a Fusion monster which is a Summoning Procedure without having to use "Polymerization". (function group) is a function with (int tp) parameter which returns a Group of usable materials. (function op) is the operation that will be applied to the selected materials. (function sumcon) adds a limitation on a Fusion monster which applies to EFFECT_SPSUMMON_CONDITION. (function condition) is an additional condition to check. (int sumtype) is the SummonType of the Contact Fusion, which defaults to 0. (int desc) is the description of the Summoning Procedure when selecting it.
---
Fusion.AddProcCode2(Card c, int code1, int code2, bool sub, bool insf) -> 
Creates a Fusion Summon recipe for a monster that uses 2 specifically named cards as materials.
---
Fusion.AddProcCode2FunRep(Card c, int code1, int code2, FusionRecipeFilter filter, int minc, int maxc, bool sub, bool insf) -> 
Creates a Fusion Summon recipe for a monster that uses 2 specifically named materials, and a range of other materials that match a filter.
---
Fusion.AddProcCode3(Card c, int code1, int code2, int code3, bool sub, bool insf) -> 
Creates a Fusion Summon recipe for a monster that uses 3 specifically named cards as materials.
---
Fusion.AddProcCode4(Card c, int code1, int code2, int code3, int code4, bool sub, bool insf) -> 
Creates a Fusion Summon recipe for a monster that uses 4 specifically named cards as materials.
---
Fusion.AddProcCodeFun(Card c, int code1, FusionRecipeFilter filter, int ct, bool sub, bool insf) -> 
Creates a Fusion Summon recipe for monsters that use 1 specifically named material, and an exact number of materials that match a filter.
---
Fusion.AddProcCodeFunRep(any c, any code1, any f, any minc, any maxc, any sub, any insf) -> 
Fusion monster, name + condition * minc to maxc
---
Fusion.AddProcCodeRep(any c, any code1, any n, any sub, any insf) -> 
Recipe for Fusion monsters that have n "code1" cards as material. Not directly called by any card.
---
Fusion.AddProcCodeRep2(any c, any code1, any minc, any maxc, any sub, any insf) -> 
Fusion monster, name * minc to maxc. not used by any card
---
Fusion.AddProcFun2(any c, any f1, any f2, any insf) -> 
Fusion monster, condition + condition
---
Fusion.AddProcFunFun(any c, any f1, any f2, any cc, any insf) -> 
Fusion monster, condition1 + condition2 * n
---
Fusion.AddProcFunFunRep(any c, any f1, any f2, any minc, any maxc, any insf) -> 
Fusion monster, condition1 + condition2 * minc to maxc
---
Fusion.AddProcFunRep(any c, any f, any cc, any insf) -> 
Fusion monster, condition * n
---
Fusion.AddProcFunRep2(any c, any f, any minc, any maxc, any insf) -> 
Fusion monster, condition * minc to maxc
---
Fusion.AddProcMix(Card c, bool sub, bool insf, int|FusionRecipeFilter|table ...) -> 
Creates a Fusion Summon recipe for a monster.
---
Fusion.AddProcMixN(Card c, bool sub, bool insf, int|function con, int ...) -> 
Adds a Fusion Procedure where (bool sub) is a check if Fusion Substitutes are allowed. (bool insf) is a check if using no materials are allowed (e.g. Instant Fusion). (int|function ...) is a list of any number of codes/conditions as Fusion Materials, by pairs wherein the first value is int/function which is the code or condition, and the second value is an int which corresponds to the number of fixed materials.
---
Fusion.AddProcMixRep(Card c, bool sub, bool insf, function fun1, int minc, int maxc, int|function ...) -> 
Adds a Fusion Procedure where (bool sub) is a check if Fusion Substitutes are allowed. (bool insf) is a check if using no materials are allowed (e.g. Instant Fusion). (function fun1) is a condition for a Fusion Material with a minimum (int minc) and maximum (int maxc) and (int|function ...) is a list of any number of codes/conditions as Fusion Materials.
---
Fusion.AddProcMixRepUnfix(any c, any sub, any insf, any ...) -> 
(To be added)
---
Fusion.AddShaddolProcMix(Card c, bool insf, function f, int att) -> 
Adds a Fusion Procedure where (bool insf) is a check if using no materials are allowed (e.g. Instant Fusion) and accepts 1 condition (function f) and 1 Attribute (int att).
---
Fusion.BanishMaterial(any e, any tc, any tp, Group sg) -> 
Banishes (group sg), face-up, with REASON_EFFECT+REASON_MATERIAL+REASON_FUSION. Then clears the group sg. Used by the Fusion Summon procedure.
---
Fusion.CheckAdditional() -> nil|function
A variable used temporarily to add further checks (e.g. only up to 2 materials from the Extra Deck: Odd-Eyes Fusion)
---
Fusion.CheckExact() -> nil|int
A variable used temporarily to limit the usable materials' number
---
Fusion.CheckWithHandler(FusionMaterialFilter fun, FusionMaterialFilter ...) -> FusionMaterialFilter
Creates a [FusionMaterialFilter](/api/types/FusionMaterialFilter) that checks if the material is also the handler of the summoning effect, along with other provided filters.
---
Fusion.CreateSummonEff(Card c, FusionMonsterFilter fusfilter, FusionMaterialFilter matfilter, FusionExtraMaterial extrafil, FusionMaterialOperation extraop, Card|Group|FusionMandatoryMaterial gc, FusionStage2 stage2, int exactcount, int sum_type, int location, int chkf, int desc, function preselect, bool nosummoncheck, EffectTarget extratg, int mincount, int maxcount, int sumpos) -> Effect
Creates an effect that performs a Fusion Summon. Can be used with Normal Spell/Trap Cards by default.
---
Fusion.ForcedHandler(Effect e) -> Card
A [FusionMandatoryMaterial](/api/types/FusionMandatoryMaterial) function that makes the handler of the effect a mandatory material.
---
Fusion.InHandMat(FusionMaterialFilter fun, FusionMaterialFilter ...) -> FusionMaterialFilter
Creates a [FusionMaterialFilter](/api/types/FusionMaterialFilter) that checks if the material is in the hand, along with other provided filters.
---
Fusion.IsMonsterFilter(FusionMaterialFilter fun, FusionMaterialFilter ...) -> FusionMaterialFilter
Creates a [FusionMaterialFilter](/api/types/FusionMaterialFilter) that checks if the material is a monster, along with other provided filters.
---
Fusion.OnFieldMat(any filter, any ...) -> bool
Used by the Fusion Summon procedure.
---
Fusion.ShuffleMaterial(any e, any tc, any tp, Group sg) -> 
Sends (group sg) to the Deck with REASON_EFFECT+REASON_MATERIAL+REASON_FUSION. Then clears the group sg. Used by the Fusion Summon procedure.
---
Fusion.SummonEffOP(FusionMonsterFilter fusfilter, FusionMaterialFilter matfilter, FusionExtraMaterial extrafil, FusionMaterialOperation extraop, Card|Group|FusionMandatoryMaterial gc, FusionStage2 stage2, int exactcount, int sum_type, int location, int chkf, int desc, function preselect, bool nosummoncheck, EffectTarget extratg, int mincount, int maxcount, int sumpos) -> EffectOperation
Creates an [EffectOperation](/api/types/EffectOperation) to be executed by a Fusion Summon effect.
---
Fusion.SummonEffTG(FusionMonsterFilter fusfilter, FusionMaterialFilter matfilter, FusionExtraMaterial extrafil, FusionMaterialOperation extraop, Card|Group|FusionMandatoryMaterial gc, FusionStage2 stage2, int exactcount, int sum_type, int location, int chkf, int desc, function preselect, bool nosummoncheck, EffectTarget extratg, int mincount, int maxcount, int sumpos) -> EffectTarget
Creates an [EffectTarget](/api/types/EffectTarget) function for a Fusion Summon effect.
---
Gemini.AddProcedure(Card c) -> 
Applies all the effects necessary for a Gemini monster to be used as one.
---
Gemini.EffectStatusCondition(Effect e) -> bool
Checks if an effect's handler (corresponding card) is a Gemini monster applying its effect.
---
Gemini.NormalStatusCondition(Effect e) -> bool
Checks if a monster is face-up and is not a Gemini monster or has not been Normal Summoned on the field.
---
Group.AddCard(Group g, Card|Group other) -> Group
Adds a card or group (Card|Group other) to a group (Group g). Returns the group itself. Equivalent to Group.Merge
---
Group.AddMaximumCheck(Group g) -> Group
Returns a group containing all the maximum parts of cards that are in maximum mode in the group g,
---
Group.CheckDifferentProperty(Group g, function f, any ...) -> bool
Function to check if every card in a group has at least a different property from the others with a function that stores the properties in multiple return forms
---
Group.CheckDifferentPropertyBinary(Group g, function f, any ...) -> bool
Function to check if every card in a group has at least a different property from the others with a function that stores the properties in binary form.
---
Group.CheckSameProperty(Group g, function f, any ...) -> bool
Returns if the members of (Group  g) share a same property, provided in (Function f)
---
Group.CheckWithSumEqual(Group g, function f, int sum, int min, int max, any ...) -> bool
Checks if there is a combination of cards, with a minimum and maximum, that has the sum of f(c,...) result equal to (int sum) in a group (Group g). Function f accepts at least one parameter (f(c,...). with c as each member of the group), and the return value should be integer. The second returned value indicates whether the check failed because of overtributing (in which case it will be true), or because of undertributing.
---
Group.CheckWithSumGreater(Group g, function f, int sum, any ...) -> bool
Checks if there is a combination of cards, with a minimum and maximum, that has the sum of f(c,...) result greater than or equal to (int sum) in a group (Group g). Function f accepts at least one parameter (f(c,...), with c as each member of the group), and the return value should be integer. The second returned value indicates whether the check failed because of overtributing (in which case it will be true), or because of undertributing.
---
Group.Clear(Group g) -> Group
Removes all the elements from a group (Group g). Returns the group itself.
---
Group.Clone(Group g) -> Group
Create a copy of a group (Group g) with the same members
---
Group.DeleteGroup(Group g) -> 
Makes a group that was kept alive be collectable (Group g)
---
Group.Equal(Group g1, Group g2) -> bool
Checks if the first group (Group g1) has the same members with the second group (Group g2)
---
Group.Filter(Group g, CardFilter filter, Group|Card|nil exc, any ...) -> Group
Creates a new `Group` with `Card`s from an original `Group` that pass a `CardFilter`.
---
Group.FilterCount(Group g, function f, Group|Card|nil ex, any ...) -> int
Counts the amount of members of a group (Group g) which meets the function (function f). Excludes a card (Card ex) if not nil. Function f accepts at least one parameter (f(c,...), with c as each member of the group), and the card will be included if f(c,...) returns true.
---
Group.FilterSelect(Group g, int player, function f, int min, int max, bool cancelable, Group|Card|nil ex, any ...) -> Group
Make a player (int player) select members of a group (Group g) which meets the function (function f), with a minimum (int min) and a maximum (int max), then outputs the result as a new Group. Excludes a card (Card ex) if not nil. Function f accepts at least one parameter (f(c,...), with c as each member of the group), and the card will be included if f(c,...) returns true. If cancelable is true and the selection is canceled nil will be returned.
---
Group.ForEach(Group g, function f, any ...) -> 
Executes a function for each card in a group (Group g), function f should accept one parameter (e.g. f(c, ...), with c as each member of the group and ... can be any number of parameters)
---
Group.FromCards(Card ...) -> Group
Creates a new Group object containing the given cards.
---
Group.FromLuaRef(int ref) -> Group
Returns a Group object from a given lua reference. The function errors out if the reference is invalid or does not refer to a Group object.
---
Group.GetBinClassCount(Group g, function f) -> int
(To be added)
---
Group.GetBitwiseAnd(Group g, function f, any ...) -> int
Gets the "bitwise and" (&) of f(c,...) result from all members of a group (Group g). Function f accepts at least one parameter (f(c,...), with c as each member of the group), and the return value should be integer.
---
Group.GetBitwiseOr(Group g, function f, any ...) -> int
Gets the "bitwise or" (|) of f(c,...) result from all members of a group (Group g). Function f accepts at least one parameter (f(c,...), with c as each member of the group), and the return value should be integer.
---
Group.GetClass(Group g, function f, any ...) -> table
Returns a table containing all the different values returned by applying the function f to all the members of the Group g,
---
Group.GetClassCount(Group g, function f, any ...) -> int
Gets the count of different f(c,...) results from all members of a group (Group g). Function f accepts at least one parameter (f(c,...), with c as each member of the group), and the return value should be integer.
---
Group.GetCount(Group g) -> int
Returns the number of cards in a group (Group g)
---
Group.GetFirst(Group g) -> Card|nil
Gets the first member of Group g (also resets the internal enumerator). Returns nil if the group is empty.
---
Group.GetLinkedZone(Group g, int cp) -> int
Returns all the zones that all the cards in g point to (on the field of player "cp").
---
Group.GetLuaRef(Group g) -> int
Returns an integer representing the internal value used by lua to access the Group g.
---
Group.GetMaxGroup(Group g, function f, any ...) -> Group
Create a new group with members from another group (Group g) which has the maximum result from f(c,...). Function f accepts at least one parameter (f(c,...), with c as each member of the group), and the return value should be integer, if the group g have no element, that function will return nil.
---
Group.GetMinGroup(Group g, function f, any ...) -> Group
Create a new group with members from another group (Group g) which has the minimum result from f(c,...). Function f accepts at least one parameter (f(c,...), with c as each member of the group), and the return value should be integer, if the group g have no element, that function will return nil.
---
Group.GetNext(Group g) -> Card|nil
Gets then next member of Group g (moves the internal enumerator by a step). Returns nil when the whole group was iterated.
---
Group.GetSum(Group g, function f, any ...) -> int
Gets the sum of f(c,...) result from all members of a group (Group g). Function f accepts at least one parameter (f(c,...), with c as each member of the group), and the return value should be integer.
---
Group.GetToBeLinkedZone(Card tc, Card c, int tp, bool clink, bool emz) -> int
Returns the zone(s) of a player "tp" such that "c" would point to "tc" if "tc" would be summoned. If "clink" is set to true it will only return the zone(s) so that "c" and "tc" would be co-linked. Set "emz" to true if the summoned monster could be placed in the Extra Monster Zone so that the possibility of Extra Linking is accounted for (see "G Golem Crystal Heart" for an example use).
---
Group.Includes(Group g1, Group g2) -> bool
Checks if (Group g1) contains all cards in (Group g2)
---
Group.IsContains(Group g, Card c) -> bool
Checks if a group (Group g) contains a specified card (Card c)
---
Group.IsDeleted(Group g) -> bool
Returns if the Group object got internally deleted and remained as dangling reference inside the lua state.
---
Group.IsExists(Group g, function f, int count, Group|Card|nil ex, any ...) -> bool
Checks if at least a number (int count) of members of a group (Group g) meet the function (function f). Excludes a card (Card ex) if not nil. Function f accepts at least one parameter (f(c,...), with c as each member of the group), and the card will be included if f(c,...) returns true.
---
Group.Iter(Group g) -> iterator
Iterates over the cards in (Group g) for use with for loops
---
Group.KeepAlive(Group g) -> Group
Makes a group (Group g) not be collected upon exiting the function. Returns the group itself.
---
Group.Match(Group g, function f, Group|Card|nil ex, any ...) -> Group
It has the same behaviour as Group.Filter but the changes are done to the Group g and no new group is created.
---
Group.Merge(Group g1, Card|Group other) -> Group
Add a card or group (Card|Group other) to a group (Group g). Returns the group itself. Equivalent to Group.AddCard
---
Group.RandomSelect(Group g, int player, int count) -> Group
Make a player (int player) randomly select (int amount) members of a group (Group g).
---
Group.Remove(Group g, function f, Group|Card|nil ex, any ...) -> Group
Removes members of a group (Group g) that meets the function (function f). Excludes a card (Card ex) from removal if not nil. Function f accepts at least one parameter (f(c,...), with c as each member of the group), and the card will be included if f(c,...) returns true. Returns the group g.
---
Group.RemoveCard(Group g, Card|Group other) -> Group
Removes from (Group g) a card or group (Card|Group other). Returns the group itself. Equivalent to Group.Sub
---
Group.SearchCard(Group g, function f, any ...) -> Card
Gets the first card found in a group (Group g) which f(c,...) returns true. Function f accepts at least one parameter (f(c,...), with c as each member of the group), and must return a boolean.
---
Group.Select(Group g, int player, int min, int max, bool cancelable) -> Group
Makes a player (int player) select members of a group (Group g), with a minimum (int min) and a maximum (int max), then outputs the result as a new Group. Excludes a card (Card ex) if it is not nil. If (bool cancelable) is true and the selection is canceled nil will be returned.
---
Group.SelectUnselect(Group g1, Group g2, int player, bool finishable, bool cancelable, int min, int max) -> Card
Selects cards in a loop that allows unselection/cancellation. (Group g1) is the group of not selected cards, (Group g2) is the group of already selected cards, (int player) is the player who selects the card, (bool finishable) indicates that the current selection has met the requirements and thus can be finished with the right click, (bool cancelable) indicates that the selection can be canceled with the right click (in the procedures this is set when the selected group is empty and no chain is going on), (int max) and (int min) does nothing to the function, they are only the max and min values shown in the hint. Every card in both the groups can be selected. The function returns a single card
---
Group.SelectWithSumEqual(Group g, int player, function f, int sum, int min, int max, any ...) -> Group
Makes a player (int player) select members of a group (Group g) which results in a combination of cards, with a minimum (int min) and maximum 9int max), that has the sum of f(c,...) result equal to (int sum). Function f accepts at least one parameter (f(c,...), with c as each member of the group), and the return value should be integer.
---
Group.SelectWithSumGreater(Group g, int player, function f, int sum, any ...) -> Group
Makes a player (int player) select members of a group (Group g) which results in a combination of cards, with a minimum and maximum, that has the sum of f(c,...) result greater than or equal to (int sum). Function f accepts at least one parameter (f(c,...), with c as each member of the group), and the return value should be integer.
---
Group.Split(Group g, function f, Group|Card|nil ex, any ...) -> Group
Returns 2 groups, the first group will contain cards matched with the same behaviour as Group.Filter, the second group will contain the remaining cards from the Group g.
---
Group.Sub(Group g1, Card|Group other) -> Group
Removes from (Group g) a card or group (Card|Group other). Returns the group itself. Equivalent to Group.Remove
---
Group.TakeatPos(Group g, int pos) -> Card|nil
Returns the card at the index specified (int pos) in the group. Returns nil if the index is greater than the size of the group.
---
Link.AddProcedure(Card c, CardFilter|nil f, int min, int max, function specialchk, int des) -> 
Adds a Link Procedure to a card.
---
Pendulum.AddProcedure(Card c, bool reg, int|nil desc) -> 
Applies to (Card c) all the effects necessary for a Pendulum card to be used as one. Setting (bool reg) to false will not register the activation effect, which is used in cards that cannot be activated since you don't have them in your hand (e.g. Xyz/Pendulums). (int desc) is an optional parameter adding a description that will be called when you try to activate in in the Pendulum Zone.
---
Ritual.AddProcEqual(Card c, function filter, int lv, int desc, function extrafil, function extraop, any matfilter, function stage2, int location, any forcedselection, any customoperation, function specificmatfilter) -> 
Adds a Ritual Summoning activation, requiring Tributes that meet (function filter), and with levels exactly equal to the Ritual Monster's level or if (int lv) is provided, with level equal to that value. (int desc) is the description when activating the Ritual Spell.
---
Ritual.AddProcEqualCode(Card c, int lv, int desc, any ...) -> 
Adds a Ritual Summoning activation, requiring Tributes with any of the card names of code (int ...), and with levels exactly equal to the Ritual Monster's level or if (int lv) is provided, with level equal to that value. (int desc) is the description when activating the Ritual Spell when provided.
---
Ritual.AddProcGreater(Card c, function filter, int lv, int desc, function extrafil, function extraop, function matfilter, function stage2, int location, any forcedselection, function customoperation, function specificmatfilter) -> Effect
Adds a Ritual Summoning activation requiring Tributes that meet (function filter), and with levels equal to or greater than the Ritual Monster's level.
---
Ritual.AddProcGreaterCode(Card c, int lv, int desc, any ...) -> 
Adds a Ritual Summoning activation requiring Tributes for a Ritual monster with any of the card names of code (int ...), and with levels equal to or greater than the Ritual Monster's level
---
Ritual.AddWholeLevelTribute(Card c, function cond) -> Effect
The current total level to match for the monster being summoned, to be used with monsters that can be used as whole tribute
---
Ritual.CreateProc(Card c, int _type, function filter, int lv, int desc, function extrafil, function extraop, function matfilter, function stage2, int location, Group forcedselection, function customoperation, function specificmatfilter) -> Effect
Creates an effect that performs a Ritual Summon. c is the card generating the effect, int _type is either RITPROC_EQUAL or RITPROC_GREATER, function filter defines the monsters can be summoned, int lv is the level of the monster(s) that must be tributed (but can be a function like GetLevel/GetOriginalLevel, a fixed level, or nil, in which case it defaults to to GetLevel), string desc is the description that will be used for that effect, function extrafil must return an extra Group that can also be used as tributed, function extraop is a custom operation to perform on the tributes (shuffle into the deck, banish,etc), function matfilter is ... . Supports named arguments for all parameters (See Revendread Evolution)
---
Spirit.AddProcedure(Card c, int event1, int ...) -> 
Sets up EVENT triggers to (Card c) so it returns to the hand during that End Phase, requires a minimum of 1 (int event1)
---
Spirit.ReturnOperation(any e, any tp, any eg, any ep, any ev, any re, any r, any rp) -> 
Auxiliary operation. Not directed used by cards.
---
Spirit.SummonRegister(any e, any tp, any eg, any ep, any ev, any re, any r, any rp) -> 
Auxiliary function registration. Not used directly by card, only called by aux.EnableSpiritReturn
---
Synchro.AddDarkSynchroProcedure(Card c, function f1, function f2, int plv, int nlv, function ...) -> 
Adds a Synchro Procedure to (Card c) used by Dark Synchros where (function f1) is the first material, usually used by the non-Tuner and (function f2) as the Dark Tuner, whose Level to be subtracted from the first material. (int plv) is the target level when both materials are of positive value while (int nlv) is the target value if the first material is affected by Dark Wave. (int plv) defaults to the Synchro monster's level while (int nlv) defaults to the (int plv) if not supplied. (function ...) is the list of required materials during the Summon.
---
Synchro.AddMajesticProcedure(Card c, function f1, bool cbt1, function f2, bool cbt2, function f3, bool cbt3, function ...) -> 
Adds a Synchro Procedure to (Card c) used by Majestic Star Dragon where (function f1, f2 and f3) are the required material and (bool cbt1, cbt2 and cbt3) are a check if the respective material can be used as the Tuner in the Summon since rulings for Majestic Star/Red Dragon state that either or both Majestic Dragon (f1) and/or Stardust Dragon/Red Dragon Archfiend (f2) can be used as the Tuner, but the non-Tuner, for the case of using Phantom King Hydride (f3) cannot be treated as the Tuner for the Summon. You require a minimum of 1 among these 3 to be the Tuner. (function ...) is the list of required materials during the Summon.
---
Synchro.AddProcedure(Card c, function f1, int min1, int max1, function f2, int min2, int max2, function sub1, function sub2, function req1, int reqct1, function req2, int reqct2, function reqm) -> 
Adds a Synchro Procedure to (Card c) where (function f1) is the required Tuner, with a minimum (int min1) and maximum (int max1). (function f2) is the second material (which usually is a non-Tuner, with a minimum (int min2) and maximum (int max2). (function sub1) is a Tuner substitute (e.g. Nirvana High Paladin) while (function sub2) is a substitute to the second material(s). (function req1) are required Tuners to be used in that Summon, with a fixed number (int reqct1) on how many are needed to be used. (function req2) follows the same pattern but for the secondary material (e.g. Crystal Wing Synchro Dragon (Anime)). (function reqm) is the required material needed to be used in that Summon regardless if it's a Tuner or the second material (e.g. function overwrite by Blackwing - Gofu the Vague Shadow (Anime)).
---
Synchro.NonTuner(function f, any a, any b, any c) -> bool
A filter used in a Synchro procedure when a material is supposed to be non-Tuner. It also has to satisfy condition of (function f) if provided with (a, b, c) parameters.
---
Synchro.NonTunerCode(table params) -> bool
Used in the Synchro Summon procedure.
---
Synchro.NonTunerEx(function f, int val) -> bool
A filter used in a Synchro procedure when a material is supposed to be non-Tuner. It also has to satisfy condition of (function f) which has to be Card.IsRace, Card.IsAttribute or Card.IsType, or a function that would use any of these 3. Also, (int val) is a parameter that is used in checking the (function f).
---
Xyz.AddProcedure(Card c, CardFilter|nil f, int|nil lv, int ct, CardFilter alterf, int desc, int maxct, XyzExtraOperation op, bool mustbemat, XyzExtraCheck exchk) -> 
Registers an effect to a card that allows it to be Xyz Summoned.
---
Xyz.ProcCancellable() -> bool
Used with the Xyz Summon procedure and a fw Xyz monsters. Defined as false.
